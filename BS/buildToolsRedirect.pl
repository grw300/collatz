#!/usr/bin/env perl
#
#  builtScripts/buildToolsRedirect.pl
#
#  DO NOT EDIT THIS FILE!  It is constructed using the file buildToolsRedirectTemplate.pl
#
#  Please see http://ss.ni.com/build for information on using the Build Services.
#
my $kBuildServicesTrunkLastChange = 'perforce://sa/ss/build/trunk/1.4/...@2009/11/24:12:30:33';

my $gScriptPerforceId = '$Id: //ComputerBasedInstruments/RF/software/rfFileIO/trunk/1.0/buildToolsRedirect.pl#1 $';
my $gBuildToolsRedirectVersion = 4;
my $kCacheFileVersionNumber = 2;
use strict;
use warnings;
use Getopt::Long;
use File::stat;
{ ###@@ Marker for Build Services - mxCrossPlatformTextFileHandle.pm @@
package mxCrossPlatformTextFileHandle;
sub TIEHANDLE
{
my $class = shift;
my $fh = \do { local *HANDLE };
bless $fh,$class;
$fh->OPEN(@_) if (@_);
return $fh;
$fh = \do { local *HANDLE };
}
sub OPEN
{
$_[0]->CLOSE if defined($_[0]->FILENO);
@_ == 2 ? open($_[0], $_[1]) : open($_[0], $_[1], $_[2]);
}
sub READLINE
{
my $self = shift;
if( wantarray )
{
my @data = ();
push @data, $_ while( $self->READLINE );
return @data;
}
else
{
if( (defined $/) && ($/ eq "\n") )
{
local($/) = "\x0A";
$_ = <$self>;
$_ =~ s/\x0D?\x0A/\n/ if defined $_;
}
else
{
$_ = <$self>;
$_ =~ s/\x0D?\x0A/\n/g if defined $_;
}
return $_;
}
}
sub PRINT
{
my $self = shift;
my $buf = join(defined $, ? $, : "",@_);
$buf .= $\ if defined $\;
$self->WRITE($buf,length($buf),0);
}
sub PRINTF
{
my $self = shift;
my $buf = sprintf(shift,@_);
$self->WRITE($buf,length($buf),0);
}
sub EOF     { eof($_[0]) }
sub TELL    { tell($_[0]) }
sub FILENO  { fileno($_[0]) }
sub SEEK    { seek($_[0],$_[1],$_[2]) }
sub CLOSE   { close($_[0]) }
sub BINMODE { binmode($_[0]) }
sub GETC    { getc($_[0]) }
sub READ    { read($_[0],$_[1],$_[2]) }
sub WRITE   { my $fh = $_[0]; print $fh substr($_[1],0,$_[2]) }
sub UNTIE   { $_[0]->CLOSE if defined($_[0]->FILENO) }
sub DESTROY { }
}
tie *TEXTFILE, 'mxCrossPlatformTextFileHandle';
my $gScriptName = ( $0 =~ /([^\\\/\:]+)$/ && $1 );
my $gHelpStr = <<EOT
\t
$gScriptName : Build Services Support Tool
 ($gScriptPerforceId)
 ($kBuildServicesTrunkLastChange)
\t
Usage: $gScriptName [--verbose] [--help]
   [--[no]ignoreCache] [--scriptType=(DOS|sh|tcsh)] [--sync=(yes|no|ask|force)]
\t
This program is used internally by the setupEnv.bat batch file on Win32
platforms and the setupEnv.sh on Linux and Mac OS X platforms. It is not
intended to be invoked directly.
\t
   -h, --help              -  Display this help and exit.
   -v, --verbose           -  Display additional information when running.
       --version           -  Print the version number of the script and exit.
       --setupEnvVersion=X -  (optional) Passed in by the calling setupEnv
                              script.  Used to specify which version of the
                              setupEnv script is running.  If not defined,
                              0 is assumed.
       --ignoreCache          ignore the local cache which contains a mapping
                              of Perforce paths to local paths for the build
                              services and the toolchain exports.
                              "noignoreCache" is the default.
       --scriptType=TYPE   -  script type to create is DOS, sh, tcsh.  If not
                              specificed, "DOS" is the default.
       --sync=MODE         -  yes, no, force, or ask.  If not specified, "yes"
                              is the default.  If the Build Services export
                              and/or the Toolchain export are not sync'ed to
                              your machine, this option defines how the script
                              behaves.  "ask" will cause the script to prompt
                              before using Perforce to sync the files.
                              "yes" will cause the script to always sync the
                              files without prompting.  "no" will cause the
                              script to never sync the files (no prompt).
                              "force" will cause the script to always sync
                              (with the "p4 sync -f" option) even if a sync
                              is not required.
       --cacheDir=DIR      -  If specified, this is the directory into which
                              the Perforce path look-up cache file and the
                              helper batch file will be written.  The default,
                              which this is not specified, is:
                                 ./objects/_dependencies/build
\t
EOT
;
sub locateAndSyncBuildServices();
my %gOptions;
my $gSyncMode;
my $gIgnoreCache;
my $gCacheDir;
my $gBuildServicesPerforcePath = '';
my $gBuildServicesLocalPath = '';
my @gENDs;
{ ###@@ Marker for Build Services - NI/Sys.pm @@
use Config;
use File::Spec::Functions;
sub cleanUpPath( $ ; $ );
sub getOsType();
sub isLinux();
sub isMacOSX();
sub isWin9x();
sub isWindows();
sub isWinNT();
sub mxCwd();
sub getOsType()
{
if($Config{'osname'} =~ /win32/i)
{
return 'windows';
}
elsif($Config{'osname'} =~ /linux/i)
{
return 'linux';
}
elsif($Config{'osname'} =~ /darwin/i)
{
return 'macosx';
}
die "NI::Sys::getOsType: ERROR - unsupported OS type. osname = '$Config{'osname'}'";
}
my $isWindowsFlag;
sub isWindows()
{
return $isWindowsFlag if defined $isWindowsFlag;
$isWindowsFlag = (getOsType() eq 'windows') ? 1 : 0;
return $isWindowsFlag;
}
sub isWin9x()
{
my $flag = 0;
if( isWindows() )
{
eval
{
require Win32;
import Win32;
if( !(Win32::IsWinNT()) )
{
$flag = 1;
}
};
die "NI::Sys::isWin9x: ERROR - Exception '$@' while using the Win32 module." if $@;
}
return $flag;
}
sub isWinNT()
{
my $flag = 0;
if(isWindows())
{
eval
{
require Win32;
import Win32;
if(Win32::IsWinNT())
{
$flag = 1;
}
};
die "NI::Sys::isWinNT: ERROR - Exception '$@' while using the Win32 module." if $@;
}
return $flag;
}
my $isLinuxFlag;
sub isLinux()
{
return $isLinuxFlag if defined $isLinuxFlag;
$isLinuxFlag = (getOsType() eq 'linux') ? 1 : 0;
return $isLinuxFlag;
}
my $isMacOSXFlag;
sub isMacOSX()
{
return $isMacOSXFlag if defined $isMacOSXFlag;
$isMacOSXFlag = (getOsType() eq 'macosx') ? 1 : 0;
return $isMacOSXFlag;
}
sub mxCwd()
{
my $cwd = $ENV{PWD};
if( $cwd )
{
$cwd =~ s@\\@/@g;
}
else
{
require Cwd;
$cwd = Cwd::cwd();
}
if( isWindows() && ($cwd =~ m@^([A-Z])(:.+)$@) )
{
$cwd = lc($1) . $2;
}
$cwd =~ s@/$@@g;
return $cwd;
}
sub cleanUpPath( $ ; $ )
{
my $path = shift;
my $forceToAbsolute = (shift or 0);
$path = File::Spec::Functions::canonpath($path);
$path =~ s@\\@/@g;
if( $path =~ m@/\.\.(/|$)@ )
{
$path .= "/"  if( $path =~ m@(^|/)\.\.$@ );
while( $path =~ s@/(?!\.\./)[^/]+/\.\./@/@ ) { };
}
if( File::Spec::Functions::file_name_is_absolute($path) )
{
if( isWindows() )
{
my ($volume,$directories,$file) = File::Spec->splitpath( $path );
if( $volume eq '' )
{
my ($cwdVolume,$cwdDirectories,$cwdFile) = File::Spec->splitpath( mxCwd() );
$path = File::Spec->catpath( $cwdVolume, $directories, $file );
}
}
}
elsif( $forceToAbsolute )
{
if( isWindows() )
{
$path = File::Spec->rel2abs( $path );
$path =~ s@\\@/@g;
}
else
{
$path = File::Spec->rel2abs( $path, mxCwd() );
if( $path =~ m@/\.\.(/|$)@ )
{
$path .= "/"  if( $path =~ m@(^|/)\.\.$@ );
while( $path =~ s@/(?!\.\./)[^/]+/\.\./@/@ ) { };
}
}
}
elsif( $path !~ /^\./ )
{
$path = "./" . $path;
}
$path =~ s@/$@@g;
if( isWindows() && ($path =~ m@^([A-Z])(:.*)$@) )
{
$path = lc($1) . $2;
}
return $path;
}
}
{ ###@@ Marker for Build Services - NI/IO.pm @@
use Carp;
sub clearDebugLogBuffer();
sub convertUnzipExitStatusToString( $ );
sub convertZipExitStatusToString( $ );
sub dumpArray( $ $ $ ; $ );
sub dumpData;
sub dumpHash( $ $ $ );
sub getDebugLogBuffer();
sub getInput( $ );
sub logStr( $ ; $ );
sub logStrNoNewline( $ ; $ );
sub mxDie( @ );
sub mxWarn( @ );
sub printStr( $ );
sub printStrNoNewline( $ );
sub setVerboseLogFilename( $ );
sub setVerboseOutput( $ );
our $kMXToolsDebugLogClientString         = 0x0001;
our $kMXToolsDebugLogInternalString       = 0x0002;
our $kMXToolsDebugLogToFile               = 0x0004;
our $kMXToolsDebugLogToFileAndStdOut      = 0x0008;
our $kMXToolsDebugAppendToLogFile         = 0x0010;
our $kMXToolsDebugNoPrefaceOnPrint        = 0x0020;
our $kMXToolsDebugNoStackTrace            = 0x0040;
our $kMXToolsDebugLogTimestamp            = 0x0080;
our $kMXToolsDebugLogToBuffer             = 0x0100;
our $kMXToolsDebugNoExtraStdout           = 0x0200;
our $kMXToolsDebugLogP4Commands           = 0x0400;
our $kMXToolsDebugLogCallerInfo           = 0x0800;
our $kMXToolsDebugLogCallerInfoFull       = 0x1000;
our $kMXToolsDebugLogShellCommands        = 0x2000;
our $gModuleVerbose = 0;
our $gVerboseOutputFlags = 0;
our $gEnvironmentInfo = '';
sub _generateLogString( $ );
sub _outputString( $ $ );
my $kFilenameMatchRegEx = qr@([^\\/]+)$@;
my $gScriptName = ( $0 =~ /([^\\\/\:]+)$/ && $1 );
my @gPerforceOperationsHistory;
my %gPerforceServerInformation = ();
my $gModuleForceDebugFlags = 0;
my $gPrintingIndent = 0;
my $gDebugLogFilename = "$gScriptName.debug.log";
my $gDebugLogFileHandle;
my $gDebugLogBuffer = '';
{
my $trace;
my $verbose = $ENV{niToolchainVerbose};
if( defined $verbose )
{
if ( $verbose =~ /\bMXTools(?:=(\S+))?\b/i )
{
$gModuleVerbose = 1;
if( defined $1 )
{
my $value = $1;
$value = hex $value if( $value =~ /^0x/i );
$gModuleForceDebugFlags = abs($value);
setVerboseOutput( $gModuleForceDebugFlags );
}
}
$trace = BlockTrace->new('::INIT', $gModuleVerbose);
logStr( "niToolchainVerbose : $verbose", $gModuleVerbose);
}
my $key = 'MAKEINCLUDE_DIR';
my $output;
if( defined $ENV{$key} )
{
$output = "env variable '$key' = '$ENV{$key}'";
}
else
{
$output = "env variable '$key' is not defined";
}
$gEnvironmentInfo .= $output;
logStr( $output, 1 ) if $gModuleVerbose;
}
my $END = sub
{
if(defined $gDebugLogFileHandle)
{
logStr '', 1;
logStr '=' x 80, 1;
logStr '=', 1;
logStr "=  Closed $gDebugLogFilename on " . localtime(), 1;
logStr '=', 1;
logStr '=' x 80, 1;
logStr '', 1;
close $gDebugLogFileHandle;
$gDebugLogFileHandle = undef;
$gVerboseOutputFlags = 0;
}
};
push @gENDs, $END;
Python::Import('atexit')->register($END) if(%Python::Object::);
our $gSimpleDieInsideEval = 0;   # 'our' so that 'local' can be used inside the eval.
my $insideMxDieCallback = 0;
sub mxDie( @ )
{
my @list = @_;
if( $^S  &&  $gSimpleDieInsideEval )
{
die @list, "\n";
}
else
{
if ($gVerboseOutputFlags & $kMXToolsDebugLogToFile)
{
print $gDebugLogFileHandle "\n\n{-mxDie" . '-' x 73 . "\n\n";
print $gDebugLogFileHandle "[$gScriptName]: ";
print $gDebugLogFileHandle @list;
print $gDebugLogFileHandle "\n\n\n";
print $gDebugLogFileHandle Carp::longmess("Stack trace begins");
print $gDebugLogFileHandle "\n\n";
$gEnvironmentInfo =~ s/^/  /gm;
print $gDebugLogFileHandle "Environment information:\n\n";
print $gDebugLogFileHandle $gEnvironmentInfo;
if( @::gPerforceOperationsHistory )
{
print $gDebugLogFileHandle "Cached Perforce server information:\n\n";
foreach my $serverName ( keys %::gPerforceServerInformation )
{
print $gDebugLogFileHandle "  Server: '$serverName'  ";
my $output = '';
dumpHash( $::gPerforceServerInformation{$serverName}, 2, \$output);
print $gDebugLogFileHandle $output . "\n";
}
print $gDebugLogFileHandle "\nLast Perforce operations (most recent first):\n\n";
my $index = 0;
foreach my $operation (reverse @::gPerforceOperationsHistory)
{
print $gDebugLogFileHandle "  [$index]:  ";
my $output = '';
dumpHash( $operation, 2, \$output);
print $gDebugLogFileHandle $output . "\n";
++$index;
}
}
print $gDebugLogFileHandle '}' . '-' x 79 . "\n\n";
}
my $callback = $main::{_mxDieCallbackFunction};
if(defined $callback && !$insideMxDieCallback)
{
logStr "mxDie: main script defines _mxDieCallbackFunction(). Calling it...", $gModuleVerbose;
$insideMxDieCallback = 1;
&$callback();
$insideMxDieCallback = 0;
}
Carp::croak "\n", "-" x 78 . "\n[$gScriptName]: ", @list, "\n\nDied";
}
}
my $insideMxWarnCallback = 0;
sub mxWarn( @ )
{
my @list = @_;
if ($gVerboseOutputFlags & $kMXToolsDebugLogToFile)
{
print $gDebugLogFileHandle "\n\n" . "-" x 80 . "\n";
print $gDebugLogFileHandle "[$gScriptName]: ";
print $gDebugLogFileHandle @list;
print $gDebugLogFileHandle "\n\n";
print $gDebugLogFileHandle Carp::longmess("Stack trace begins");
print $gDebugLogFileHandle "\nWARNING\n";
print $gDebugLogFileHandle "-" x 80 . "\n\n";
}
my $callback = $main::{_mxWarnCallbackFunction};
if(defined $callback && !$insideMxWarnCallback)
{
logStr "mxWarn: main script defines _mxWarnCallbackFunction(). Calling it...", $gModuleVerbose;
$insideMxWarnCallback = 1;
&$callback();
$insideMxWarnCallback = 0;
}
if( @list && $list[-1] =~ /\n\Z/ )  # If the warning already ends in a newline, don't print
{
warn "Warning: ", @list;
}
else
{
Carp::carp "[$gScriptName]: ", @list, " -- Warning";
}
}
sub setVerboseOutput( $ )
{
my $flag = shift;
$flag = 0 if (!defined $flag);
$flag = abs($flag);
$flag |= $gModuleForceDebugFlags;
if($flag)
{
$gVerboseOutputFlags = $flag;
if($flag & $kMXToolsDebugLogClientString)
{
$flag &= ~$kMXToolsDebugLogClientString;
}
if($flag & $kMXToolsDebugLogInternalString)
{
$flag &= ~$kMXToolsDebugLogInternalString;
}
if($flag & $kMXToolsDebugLogToFile)
{
$flag &= ~$kMXToolsDebugLogToFile;
$flag |= $kMXToolsDebugNoStackTrace;
my $openMode = ">";
if($flag & $kMXToolsDebugLogToFileAndStdOut)
{
$flag &= ~$kMXToolsDebugLogToFileAndStdOut;
}
if($flag & $kMXToolsDebugAppendToLogFile)
{
$flag &= ~$kMXToolsDebugAppendToLogFile;
$openMode .= ">";
}
if($flag & $kMXToolsDebugNoExtraStdout)
{
$flag &= ~$kMXToolsDebugNoExtraStdout;
}
if(defined $gDebugLogFileHandle)
{
logStr "setVerboseOutput: the debug file is already open. not reopening it.", $gModuleVerbose;
}
else
{
$gDebugLogFilename = ::cleanUpPath( $gDebugLogFilename, 1 );
print "Logging enabled to: $gDebugLogFilename\n"
unless ( $gVerboseOutputFlags & $kMXToolsDebugNoExtraStdout );
require IO::File;
$gDebugLogFileHandle = new IO::File;
if( !open( $gDebugLogFileHandle, "${openMode}$gDebugLogFilename" ) )
{
$gDebugLogFileHandle = undef;
die "\n[$gScriptName]: ERROR:  Unable to open the debug log file " .
"'$gDebugLogFilename' for output.  The error is \"$!\".  Died";
}
$gDebugLogFileHandle->autoflush(1);
logStr '', 1;
logStr '=' x 80, 1;
logStr '=', 1;
if($gVerboseOutputFlags & $kMXToolsDebugAppendToLogFile)
{
logStr "=  Opened $gDebugLogFilename (append) for debug output on " . localtime(), 1;
}
else
{
logStr "=  Opened $gDebugLogFilename for debug output on " . localtime(), 1;
}
logStr '=', 1;
logStr '=' x 80, 1;
logStr '', 1;
}
}
if($flag & $kMXToolsDebugNoPrefaceOnPrint)
{
$flag &= ~$kMXToolsDebugNoPrefaceOnPrint;
}
if($flag & $kMXToolsDebugNoStackTrace)
{
$flag &= ~$kMXToolsDebugNoStackTrace;
}
else
{
eval
{
require Carp;
import Carp qw(verbose);
};
}
if($flag & $kMXToolsDebugLogTimestamp)
{
$flag &= ~$kMXToolsDebugLogTimestamp;
}
if($flag & $kMXToolsDebugLogToBuffer)
{
$flag &= ~$kMXToolsDebugLogToBuffer;
if($flag & $kMXToolsDebugLogToFileAndStdOut)
{
$flag &= ~$kMXToolsDebugLogToFileAndStdOut;
}
}
if($flag & $kMXToolsDebugLogP4Commands)
{
$flag &= ~$kMXToolsDebugLogP4Commands;
}
if($flag & $kMXToolsDebugLogCallerInfo)
{
$flag &= ~$kMXToolsDebugLogCallerInfo;
}
if($flag & $kMXToolsDebugLogCallerInfoFull)
{
$flag &= ~$kMXToolsDebugLogCallerInfoFull;
}
if($flag & $kMXToolsDebugLogShellCommands)
{
$flag &= ~$kMXToolsDebugLogShellCommands;
}
if( $flag )
{
mxWarn sprintf( "Error! You have set the debug level to 0x%x (unknown bits 0x%x). " .
"This is not a valid value. You may not see any debug output.",
$gVerboseOutputFlags, $flag );
}
logStr sprintf("setVerboseOutput: debug flags = 0x%4.4x", $gVerboseOutputFlags), $gModuleVerbose;
}
else
{
logStr "setVerboseOutput: debug disabled", $gModuleVerbose;
$gVerboseOutputFlags = 0;
}
}
sub setVerboseLogFilename( $ )
{
$gDebugLogFilename = shift;
}
sub getDebugLogBuffer()
{
return $gDebugLogBuffer;
}
sub clearDebugLogBuffer()
{
$gDebugLogBuffer = '';
}
sub printStr( $ )
{
my $string = shift;
$string .= "\n";
if( ($gVerboseOutputFlags & ( $kMXToolsDebugLogClientString |
$kMXToolsDebugLogInternalString ) ) &&
!($gVerboseOutputFlags & $kMXToolsDebugNoPrefaceOnPrint) )
{
$string = _generateLogString( $string );
}
_outputString( $string, 0 );
}
sub printStrNoNewline( $ )
{
my $string = shift;
if( ($gVerboseOutputFlags & ( $kMXToolsDebugLogClientString |
$kMXToolsDebugLogInternalString ) ) &&
!($gVerboseOutputFlags & $kMXToolsDebugNoPrefaceOnPrint) )
{
$string = _generateLogString( $string );
}
local $| = 1;
_outputString( $string, 0 );
}
sub logStr( $ ; $ )
{
my $stringToLog = shift;
my $flag = shift;
if(defined($flag))
{
return unless ( $flag || ($gVerboseOutputFlags & $kMXToolsDebugLogInternalString) );
}
else
{
return unless ( $gVerboseOutputFlags & $kMXToolsDebugLogClientString );
}
$stringToLog .= "\n";
_outputString( _generateLogString( $stringToLog ), 1 );
}
sub logStrNoNewline( $ ; $ )
{
my $stringToLog = shift;
my $flag = shift;
if(defined($flag))
{
return unless ( $flag || ($gVerboseOutputFlags & $kMXToolsDebugLogInternalString) );
}
else
{
return unless ( $gVerboseOutputFlags & $kMXToolsDebugLogClientString );
}
_outputString( _generateLogString( $stringToLog ), 1 );
}
sub getInput( $ )
{
my $prompt = shift;
{
local $| = 1;
printStrNoNewline( "$prompt " );
}
my $input = <STDIN>;
printStr '';
chomp ($input);
logStr( "Received input: '$input'" );
return $input;
}
sub _generateLogString( $ )
{
my $clientString = shift;
my $info;
if( $gVerboseOutputFlags &
($kMXToolsDebugLogCallerInfo | $kMXToolsDebugLogCallerInfoFull) )
{
my ($package, $filename, $line) = caller(1);
if( $package eq 'MXToolsBlockTrace' || $package eq 'BlockTrace' )
{
($package, $filename, $line) = caller(2);
}
if($gVerboseOutputFlags & $kMXToolsDebugLogCallerInfoFull)
{
$info = "$package-$filename-$line";
}
else
{
$filename = ( $filename =~ $kFilenameMatchRegEx && $1 );
$info = sprintf( "%-16.16s-%-16.16s-%05.5d", $package, $filename, $line );
}
}
else
{
$info = $gScriptName;
}
if($gVerboseOutputFlags & $kMXToolsDebugLogTimestamp)
{
my ($sec,$min,$hour,$day,$month,$year) = localtime();
$info .= sprintf( "-%04.4d_%02.2d_%02.2d-%02.2d:%02.2d:%02.2d", $year + 1900, $month + 1, $day, $hour, $min, $sec );
}
my $logString = "[$info]: ";
$gPrintingIndent-- if( $clientString =~ /^\}/ );
$logString .= '  ' x $gPrintingIndent . $clientString;
$gPrintingIndent++ if( $clientString =~ /^\{(\W|$)/ );
return $logString;
}
sub _outputString( $ $ )
{
my $string = shift;
my $calledByLogStr = shift;
if ($gVerboseOutputFlags & $kMXToolsDebugLogToBuffer)
{
$gDebugLogBuffer .= $string;
}
if ($gVerboseOutputFlags & $kMXToolsDebugLogToFile)
{
print $gDebugLogFileHandle $string;
}
if($calledByLogStr)
{
if( $gVerboseOutputFlags & ($kMXToolsDebugLogToFile | $kMXToolsDebugLogToBuffer) )
{
if($gVerboseOutputFlags & $kMXToolsDebugLogToFileAndStdOut)
{
print $string;
}
}
else
{
print $string;
}
}
else
{
print $string;
}
}
sub dumpData
{
my $results;
eval
{
require YAML;
import YAML;
$results = &YAML::Dump;
};
if( $@ )
{
$results = '';
::logStr( "Unable to dump the given Perl data structure.\n" .
"Perl message: $@\n", $gModuleVerbose );
}
return $results;
}
sub dumpHash( $ $ $ )
{
my $hashRef = shift;
my $level = shift;
my $outputStringRef = shift;
$$outputStringRef .= dumpData( $hashRef );
}
sub dumpArray( $ $ $ ; $ )
{
my $arrayRef = shift;
my $level = shift;
my $outputStringRef = shift;
my $recursiveCallParameter = shift;
$$outputStringRef .= dumpData( $arrayRef );
}
package BlockTrace;
sub new {
my $proto = shift;
my $class = ref($proto) || $proto;
my $self  = {};
my $stringToLog = shift;
my $flag = shift;
if( defined($flag) )
{
$self->{VERBOSE} = $flag;
}
::logStr $stringToLog, $flag;
::logStr '{', $flag;
bless ($self, $class);
return $self;
}
sub DESTROY {
my $self = shift;
if( defined($self->{VERBOSE}) )
{
::logStr '}', $self->{VERBOSE};
}
else
{
::logStr '}';
}
}
}
{ ###@@ Marker for Build Services - NI/Process.pm @@
use File::Temp;
sub parseCommandLineIntoArray( $ );
sub shellCommand( $ ; @ );
sub startSysCmd( $ $ $ $ ; @ );
sub waitForSysCmd( $ ; @ );
sub makeSystemCall( @ );
sub _flattenArrayIntoCommandLine( $ @ );
my $gEndOfFileMarker = ::isWindows() ? "\x1A" : '';
my $gModuleVerbose = $::gModuleVerbose;
my %gPidToCommandHash;
sub shellCommand( $ ; @ )
{
my $commandParameter = shift;
my %options = @_;
my $noisy = ( $gModuleVerbose || ($::gVerboseOutputFlags & $::kMXToolsDebugLogShellCommands) );
my $trace = BlockTrace->new( "NI::Process::shellCommand()", $noisy );
if( $noisy && scalar keys %options )
{
my $debugString = "";
::dumpHash( \%options, 1, \$debugString );
::logStr( "\%options : $debugString", 1 );
}
my $dieOnOpenFailure    = exists($options{dieOnOpenFailure}) ? $options{dieOnOpenFailure} : 1;
my $dieOnCommandFailure = exists($options{dieOnCommandFailure}) ? $options{dieOnCommandFailure} : 1;
if( $options{noDie} )
{
$dieOnOpenFailure = 0;
$dieOnCommandFailure = 0;
}
my $extendedDieMessage  = $options{extendedDieMessage} || '';
my $warnOnWaitPidFailure= exists($options{warnOnWaitPidFailure}) ? $options{warnOnWaitPidFailure} : 1;
my $printCommandOutput  = exists($options{printCommandOutput}) ? $options{printCommandOutput} : 1;
my $logCommandOutput    = exists($options{logCommandOutput}) ? $options{logCommandOutput} : $noisy;
my $logCommand          = exists($options{logCommand}) ? $options{logCommand} : 0;
my $escapeWildcards     = exists($options{escapeWildcards}) ? $options{escapeWildcards} : 0;
my $outputLineCallback;
if( exists $options{outputLineCallback} )
{
$outputLineCallback = $options{outputLineCallback};
mxDie "Error: The 'outputLineCallback' option to the ::shellCommand function " .
"must be a code (function) reference.  It is not.  Please fix the call to " .
"this function." if( ref($outputLineCallback) ne "CODE" );
}
my $callerWantsArray = (wantarray ? 1 : 0);
my $runShellCommand;
my $outputString = '';
my $processExitStatus = -1;
my $exitCode = -1;
my $extra = '';
my $commandLine;
my @command;
if( ref($commandParameter) eq 'ARRAY' )
{
@command = @{$commandParameter};
$commandLine = _flattenArrayIntoCommandLine( $escapeWildcards, @command );
$extra .= ' [flattened]';
}
else
{
@command = parseCommandLineIntoArray( $commandParameter );
$commandLine = _flattenArrayIntoCommandLine( $escapeWildcards, @command );
$extra .= ' [re-flattened]';
}
if( ! $commandLine )
{
mxDie "Error: No external command was passed to this function. " .
"This is a usage error for ::shellCommand.";
}
my $cmdName = ( $command[0] =~ /([^\\\/\:]+)$/ && $1 );
my $originalWorkingDirectory;
if( defined $options{workingDir} )
{
my $newDir = ::cleanUpPath( $options{workingDir},
1
);
$originalWorkingDirectory = mxCwd();
::logStr( "Changing the current working directory to \"$newDir\"", $noisy );
chdir $options{workingDir}
or mxDie "Unable to change the current working directory to " .
"\"$newDir\".  The error is \"$!\"\n";
}
my $pid;
my $callbackCoderefParam = sub
{
my $trace = BlockTrace->new( "NI::Process::shellCommand -- outputLineCallback -- killFunc", $noisy );
if( $pid )
{
::logStr( "Calling \"kill TERM\" on pid $pid.", $noisy );
kill('TERM', $pid);
delete $gPidToCommandHash{$pid};
}
};
unless( (::isWindows() && (length($commandLine) > 8100)) ||
$options{_useOpen3_} )
{
::logStr( "command$extra: `$commandLine`  [length: " . length($commandLine) . "]", $noisy );
::logStr( "command: `$commandLine`" ) if ( !$noisy && $logCommand );
$runShellCommand = sub
{
my $extra = '';
my $tempfile;
if( defined $options{stdin} )
{
$tempfile = new File::Temp();
binmode $tempfile, ':crlf' if ::isWindows();
$tempfile->unlink_on_destroy(0) if $gModuleVerbose;
print $tempfile $options{stdin};
::logStr( "  stdin from: $tempfile", $noisy );
$extra = "<$tempfile";
}
$pid = open(RDR, "$commandLine 2>&1 $extra|");
mxDie( "Can't open '$commandLine 2>&1 $extra|'\n" .
"Error: '$!'\n" .
(isWindows() ? "Extended OS error: '$^E'\n" : '' ) .
$extendedDieMessage )
if( $dieOnOpenFailure && !$pid );
if( $pid )
{
$gPidToCommandHash{$pid} = \@command;
::logStr( "  pid: $pid", $noisy );
while( <RDR> )
{
$_ =~ s/\x0D*\x0A/\n/;
$outputString .= $_ if $callerWantsArray;
::printStrNoNewline( $_ ) if $printCommandOutput;
::logStrNoNewline( "[$cmdName]: " . $_ ) if $logCommandOutput;
if( $outputLineCallback &&
&$outputLineCallback( $_, $pid, $callbackCoderefParam ) == 1 )
{
::logStr( "The outputLineCallback function returned 1, killing " .
"command and returning from shellCommand immediately.", $noisy );
if( $gPidToCommandHash{$pid} )
{
::logStr( "Calling \"kill TERM\" on pid $pid.", $noisy );
kill('TERM', $pid);
delete $gPidToCommandHash{$pid};
}
close RDR;
$exitCode = -2;
$processExitStatus = -2;
return;
}
}
my $closeResult = close RDR;
$processExitStatus = $?;
if( !$closeResult  &&  $!  &&  $warnOnWaitPidFailure )
{
::logStr "close() for '$cmdName' returned false, \$OS_ERROR is '$!'. " .
"Failing anyway, in case it's because Ctrl-C was pressed.\n";
}
if( $outputLineCallback &&
&$outputLineCallback( undef, $pid, $callbackCoderefParam ) == 1 )
{
::logStr( "The outputLineCallback [cleanup] function returned 1, " .
"returning from shellCommand immediately.", $noisy );
delete $gPidToCommandHash{$pid};
$exitCode = -2;
$processExitStatus = -2;
return;
}
waitpid($pid, 0);
delete $gPidToCommandHash{$pid};
$pid = undef;
if( $processExitStatus & 0xFF )
{
$exitCode = -1;
}
else
{
$exitCode = $processExitStatus >> 8;
$exitCode = ($exitCode - 256)  if( $exitCode > 127 );
}
if( $dieOnCommandFailure  &&  $processExitStatus != 0 )
{
if( $processExitStatus & 0xFF )
{
mxDie "External command died with a signal.\n" .
" command : $commandLine\n" .
" signal  : " . ($processExitStatus & 0xFF) . "\n" .
( $extendedDieMessage ?
" info    : $extendedDieMessage\n" : '');
}
else
{
mxDie "External command exited with a non-zero exit code.\n" .
" command : $commandLine\n" .
" status  : $exitCode\n" .
( $extendedDieMessage ?
" info    : $extendedDieMessage\n" : '');
}
}
}
return;
};
}
elsif( %Python::Object:: && ::isWindows() )
{
::logStr( "command line too long for cmd.exe (" . length($commandLine) .
" chars). Using Python's subprocess.Popen() instead.", $gModuleVerbose );
$extra = ' [Popen]';
$extra .= ' [parsed]' if( ref($commandParameter) ne 'ARRAY' );
::logStr( "command$extra: `@command`", $noisy );
::logStr( "command: `@command`" ) if ( !$noisy && $logCommand );
$runShellCommand = sub
{
Python::exec('import subprocess');
my $extra = '';
$extra = 'stdin=subprocess.PIPE,' if defined $options{stdin};
Python::exec('def shellCommand(args):' .
" return subprocess.Popen(args, $extra stdout=subprocess.PIPE, stderr=subprocess.STDOUT)");
my $pythonShellCommand = Python::eval('shellCommand');
my $proc = eval{ &$pythonShellCommand(\@command); };
mxDie( "Can't run `@command`: $@.\n  $extendedDieMessage" ) if( $dieOnOpenFailure && !$proc );
if( $proc )
{
$pid = $proc->pid;
if( defined $options{stdin} )
{
$proc->stdin->write($options{stdin});
$proc->stdin->close();
}
while( $_ = $proc->stdout->readline() )
{
$_ =~ s/\x0D*\x0A/\n/;
$outputString .= $_ if $callerWantsArray;
::printStrNoNewline( $_ ) if $printCommandOutput;
::logStrNoNewline( "[$cmdName]: " . $_ ) if $logCommandOutput;
if( $outputLineCallback &&
&$outputLineCallback( $_, $pid, $callbackCoderefParam ) == 1 )
{
::logStr( "The outputLineCallback function returned 1, killing " .
"command and returning from shellCommand immediately.", $gModuleVerbose );
if( $gPidToCommandHash{$pid} )
{
::logStr( "Calling \"kill TERM\" on pid $pid.", $gModuleVerbose );
kill('TERM', $pid);
delete $gPidToCommandHash{$pid};
}
$proc->stdout->close();
$proc->wait();
$exitCode = -2;
$processExitStatus = -2;
return;
}
}
$proc->stdout->close();
if( $outputLineCallback &&
&$outputLineCallback( undef, $pid, $callbackCoderefParam ) == 1 )
{
::logStr( "The outputLineCallback [cleanup] function returned 1, " .
"returning from shellCommand immediately.", $gModuleVerbose );
delete $gPidToCommandHash{$pid};
$exitCode = -2;
$processExitStatus = -2;
return;
}
$exitCode = $proc->wait();
$processExitStatus = $exitCode << 8;
if( $dieOnCommandFailure  &&  $exitCode != 0 )
{
mxDie "External command exited with a non-zero exit code.\n" .
" command : $commandLine\n" .
" status  : $exitCode\n" .
( $extendedDieMessage ?
" info    : $extendedDieMessage\n" : '');
}
}
return;
};
}
else
{
::logStr( "command line too long for cmd.exe (" . length($commandLine) .
" chars). Using open3() instead.", $noisy );
$extra = ' [open3]';
$extra .= ' [parsed]' if( ref($commandParameter) ne 'ARRAY' );
::logStr( "command$extra: `@command`", $noisy );
::logStr( "command: `@command`" ) if ( !$noisy && $logCommand );
$runShellCommand = sub
{
my ($wtr, $rdr);
$pid = startSysCmd( \@command,
$wtr,  #  tied to command's STDIN
$rdr,  #  tied to command's STDOUT
$rdr,  #  and also tied to command's STDERR
dieOnFailure => $dieOnOpenFailure,
extendedDieMessage => $extendedDieMessage
);
if( $pid )
{
print $wtr "$options{stdin}$gEndOfFileMarker" if defined $options{stdin};
close $wtr;
while( <$rdr> )
{
$_ =~ s/\x0D*\x0A/\n/;
$outputString .= $_ if $callerWantsArray;
::printStrNoNewline( $_ ) if $printCommandOutput;
::logStrNoNewline( "[$cmdName]: " . $_ ) if $logCommandOutput;
if( $outputLineCallback &&
&$outputLineCallback( $_, $pid, $callbackCoderefParam ) == 1 )
{
::logStr( "The outputLineCallback function returned 1, killing " .
"command and returning from shellCommand immediately.", $noisy );
if( $gPidToCommandHash{$pid} )
{
::logStr( "Calling \"kill TERM\" on pid $pid.", $noisy );
kill('TERM', $pid);
delete $gPidToCommandHash{$pid};
}
close $rdr;
$exitCode = -2;
$processExitStatus = -2;
return;
}
}
close $rdr;
if( $outputLineCallback &&
&$outputLineCallback( undef, $pid, $callbackCoderefParam ) == 1 )
{
::logStr( "The outputLineCallback [cleanup] function returned 1, " .
"returning from shellCommand immediately.", $noisy );
delete $gPidToCommandHash{$pid};
$exitCode = -2;
$processExitStatus = -2;
return;
}
$processExitStatus = waitForSysCmd( $pid,
dieOnFailure => $dieOnCommandFailure,
warnOnWaitPidFailure => $warnOnWaitPidFailure,
extendedDieMessage => $extendedDieMessage
);
if( $processExitStatus & 0xFF )
{
$exitCode = -1;
}
else
{
$exitCode = $processExitStatus >> 8;
$exitCode = ($exitCode - 256)  if( $exitCode > 127 );
}
}
return;
};
}
if( ::isWindows() )
{
my $hitCtrlC = 0;
my $oldSigInt = $SIG{INT};
my $sigIntHandler = sub
{
$hitCtrlC = 1;
if( $pid && ! $options{noKillOnCtrlC} )
{
kill('TERM', $pid);
}
&$oldSigInt()  if( $oldSigInt );
};
local $SIG{INT} = $sigIntHandler;
local $SIG{TERM} = $sigIntHandler;
local $SIG{BREAK} = $sigIntHandler  if( ::isWindows() );
&$runShellCommand();
if( $hitCtrlC )
{
::logStr( "Captured Ctrl-C" );
$exitCode ||= -1;
exit $exitCode  if( $options{dieOnCommandFailure} );
}
}
else
{
&$runShellCommand();
}
if( $originalWorkingDirectory )
{
::logStr( "Changing the current working directory back to \"$originalWorkingDirectory\"", $noisy );
chdir $originalWorkingDirectory
or mxDie "Unable to change the current working directory back to " .
"\"$originalWorkingDirectory\".  The error is \"$!\"\n";
}
::logStr( "command exit code: $exitCode,  process exit status: $processExitStatus", $noisy );
return $callerWantsArray ? ( $exitCode, $outputString, $processExitStatus ) : $exitCode;
}
sub startSysCmd( $ $ $ $ ; @ )
{
my $cmd = shift;
my %opts = @_[3 .. $#_];
my @command;
if( ref($cmd) eq 'ARRAY' )
{
@command = @$cmd;
}
else
{
@command = parseCommandLineIntoArray( $cmd );
}
my $dieOnFailure = exists($opts{dieOnFailure}) ? $opts{dieOnFailure} : 1;
my $extendedDieMessage = ($opts{extendedDieMessage} or '');
delete $opts{dieOnFailure};
delete $opts{extendedDieMessage};
mxDie "Internal Error: Unknown options passed to ::startSysCmd" if( keys %opts );
require IPC::Open3;
my $pid = IPC::Open3::open3( $_[0],  #  tied to command's STDIN
$_[1],  #  tied to command's STDOUT
$_[2],  #  tied to command's STDERR
@command );
mxDie( "Can't run `@command`: $!.\n  $extendedDieMessage" ) if( $dieOnFailure && !$pid );
$gPidToCommandHash{$pid} = \@command  if( $pid );
return $pid;
}
sub waitForSysCmd( $ ; @ )
{
my $pid = shift;
my %opts = @_;
my $dieOnFailure         = exists($opts{dieOnFailure}) ? $opts{dieOnFailure} : 1;
my $warnOnWaitPidFailure = exists($opts{warnOnWaitPidFailure}) ? $opts{warnOnWaitPidFailure} : 1;
my $extendedDieMessage   = ($opts{extendedDieMessage} or '');
my $waitpidOptions       = ($opts{waitpidOptions} or 0);
delete $opts{dieOnFailure};
delete $opts{warnOnWaitPidFailure};
delete $opts{extendedDieMessage};
delete $opts{waitpidOptions};
mxDie "Unknown options passed to ::waitForSysCmd" if( keys %opts );
return if( !$pid );
my @command = @{ $gPidToCommandHash{$pid} };
delete $gPidToCommandHash{$pid};
my $waitStatus = waitpid( $pid, $waitpidOptions );
my $processExitStatus = $?;
if( $waitStatus == -1 )
{
$processExitStatus = 0;
if( $warnOnWaitPidFailure )
{
my $cmdName = ( $command[0] =~ /([^\\\/\:]+)$/ && $1 );
mxWarn "Warning: waitpid() for '$cmdName' returned -1. Assuming success.";
}
}
elsif( $dieOnFailure  &&  $processExitStatus != 0 )
{
if( $processExitStatus & 0xFF )
{
mxDie "External command died with a signal.\n" .
" command : @command\n" .
" signal  : " . ($processExitStatus & 0xFF) . "\n" .
( $extendedDieMessage ?
" info    : $extendedDieMessage\n" : '');
}
else
{
my $exitCode = $processExitStatus >> 8;
if( $exitCode != 0 )
{
if( $exitCode > 127 )
{
$exitCode = $exitCode - 256;
}
mxDie "External command exited with a non-zero exit code.\n" .
" command : @command\n" .
" status  : $exitCode\n" .
( $extendedDieMessage ?
" info    : $extendedDieMessage\n" : '');
}
}
}
return $processExitStatus;
}
sub makeSystemCall( @ )
{
my $programName = shift;
my @programArguments = @_;
my $trace = BlockTrace->new("NI::Process::makeSystemCall", $gModuleVerbose);
my $returnValue = -1;
if(::isWin9x())
{
my $batchFile = "_temp.bat";
my $batchFileNumber = 0;
while(-f $batchFile)
{
$batchFileNumber++;
$batchFile = "_temp${batchFileNumber}.bat"
}
$programName =~ s(/)(\\)g;
::logStr "Win9x: Creating a temporary batch file ($batchFile)", $gModuleVerbose;
open BATCHFILE, ">$batchFile"
or mxDie "NI::Process::makeSystemCall: ERROR - Can't open $batchFile for writing : $!";
::logStr "Writing command-line: $programName @programArguments", $gModuleVerbose;
print BATCHFILE "\@echo off\n"
or mxDie "NI::Process::makeSystemCall: ERROR - Can't write to $batchFile : $!";
print BATCHFILE "$programName @programArguments\n"
or mxDie "NI::Process::makeSystemCall: ERROR - Can't write to $batchFile : $!";
close BATCHFILE;
::logStr "Calling the batch file", $gModuleVerbose;
$returnValue = system($batchFile);
unlink($batchFile) unless $gModuleVerbose;
}
else
{
::logStr ::getOsType() . ": Calling $programName @programArguments", $gModuleVerbose;
$returnValue = system($programName, @programArguments);
}
::logStr "system call returned the status $returnValue", $gModuleVerbose;
return $returnValue;
}
sub parseCommandLineIntoArray( $ )
{
my $commandLine = shift;
my $trace;
$trace = BlockTrace->new( "NI::Process::parseCommandLineIntoArray( " .
"\"$commandLine\" )", 1 )
if ($::gVerboseOutputFlags & $::kMXToolsDebugLogShellCommands);
my @args;
my $item = '';
my $quoted = 0;
my $escaped = 0;
my $length = length $commandLine;
for( my $index = 0 ; $index < $length ; $index++ )
{
my $char = substr $commandLine, $index, 1;
if( $escaped )
{
$escaped = 0;
if ( ::isWindows() )
{
$item .= '\\' if( $char ne '"' );
$item .= $char;
}
else
{
if( $quoted )
{
unless( $char =~ /[\$\`\"\\]/ )
{
$item .= '\\';
}
$item .= $char;
}
else
{
$item .= $char;
}
}
}
elsif( !$quoted && ($char =~ /\s/) )
{
push @args, $item if ($item ne '');
$item = '';
}
elsif( $char eq '\\' )
{
$escaped = 1;
}
elsif( $char eq '"' )
{
$quoted = !$quoted;
}
else
{
$item .= $char;
}
}
push @args, $item if ($item ne '');
::logStr( "returning an array of " . scalar(@args) . " items", 1 )
if($::gVerboseOutputFlags & $::kMXToolsDebugLogShellCommands);
return @args;
}
sub _flattenArrayIntoCommandLine( $ @ )
{
my $escapeWildcards = shift;
my @command = @_;
my $commandLine = '';
foreach my $arg (@command)
{
if( ::isWindows() )
{
if( $arg !~ /^".*"$/ )
{
$arg =~ s/(?<!\\)"/\\"/g;
if( $arg =~ /[\s&%<>|{}'^]/ )
{
$arg = "\"$arg\"";
}
}
}
else
{
if( $arg !~ /^(['"]).*\1$/ )
{
if( $arg =~ /\s/ )
{
$arg =~ s/(?<!\\)(["\$\`\\<>|])/\\$1/g;
$arg = "\"$arg\"";
}
else
{
$arg =~ s/(?<!\\)(["'\$\`\\<>|();&])/\\$1/g;
$arg =~ s/(?<!\\)([?*])/\\$1/g if $escapeWildcards;
}
}
}
$commandLine .= "$arg ";
}
chop $commandLine;
return $commandLine;
}
}
{ ###@@ Marker for Build Services - NI/P4.pm @@
use File::Find;
use File::Path;
sub cleanupP4ServerName( $ );
sub constructFileServerPath( $ ; $ $ );
sub createP4Changelist( $ ; $ );
sub getChangelistInfo( $ $ );
sub getFileServerName( $ ; $ );
sub getKnownPerforceServersList;
sub getListOfDirectories( $ $ ; @ );
sub getListOfFiles( $ $ $ ; @ );
sub getPerforceConnectionRetryTime( );
sub getPerforceServerClientspec( $ );
sub getPerforceServerPort( $ );
sub getPerforceServerTime( $ );
sub isExportStoredOnFileServer( $ );
sub isP4FileUpToDate( $ );
sub isPerforceServerAvailable( ; $ );
sub p4Cmd( $ $ ; @ );
sub p4Command( $ ; $ );
sub p4ModuleIsInUse( );
sub p4PathCheck( $ ; $ );
sub p4PathExists( $ );
sub p4Sync( $ ; @ );
sub p4Where( $ ; $ $ );
sub readP4FileBySyncOrPrint( $ ; @ );
sub resolvePath;
sub resolvePaths;
sub setGlobalP4CmdOptionsForServer( $ @ );
sub setPerforceConnectionRetryTime( $ );
sub setPerforceOperationsHistoryLength( $ );
sub setPerforceOptions( $ );
sub validatePerforcePathCase( $ ; $ );
our $gP4Err;
our $gP4ErrNo;
our $gP4RawOutput;
sub _addNFSPathData( $ $ );
sub _addUNCPathData( $ $ );
sub _cacheExportLocationFile( $ );
sub _checkForSharePathMatch;
sub _checkPerforceDepot( $ );
sub _collectZipItems( $ $ $ $ $ );
sub _copyFilesToLocalDisk( $ $ $ $ $ $ );
sub _createRootMatchExpression;
sub _deleteFilesFromLocalDisk( $ $ $ $ $ );
sub _fileInfo( $ );
sub _findMatchingServerInP4TicketFile( $ );
sub _getDepotNameString( $ );
sub _getEnvValue( $ );
sub _getFileServerPathData( $ $ );
sub _getListOfDirectoriesFromZips( $ $ $ );
sub _getListOfFilesFromZips( $ $ $ );
sub _isDirectory( $ );
sub _macosxCopyFile( \@ $ $ $ $ );
sub _obtainInfoForDefaultPerforceServer( );
sub _p4Cmd_internal( $ $ $ $ $ $ @ );
sub _p4SyncNetworkPath( $ $ $ );
sub _p4SyncPerforcePath( $ $ $ );
sub _parseExportLocationFileData( $ $ $ );
sub _processZipFiles( $ $ $ );
sub _readExportLocationFile( $ $ $ );
sub _readFileServerMirrorsFile( );
sub _resolvePathsOnServer;
sub _updateOnePerforceServer( $ );
sub _updatePerforceServerInfo( $ );
my $kZipFilesDirectory = '.archives';
my $kCorrectPerforcePathRegEx = qr@^\s*(?:([\w\-]+):)?(//.+?)(?:/)?\s*$@;
my $kClientDefaultPerforceServer     = '__default_perforce_server__';
my $kClientDefaultPerforceClientspec = '__default_perforce_clientspec__';
our $kExportPathMatchRegEx =
qr@^(
(.+/ ([^/]+) )/
export/
(\d\d0|\d+\.\d+)/
(
(?:\d\d\d|\d+\.\d+\.\d+) [dabf]\d+ (?: \.\d+ )?
)
)
( /(.+?) )?
$@x;
my %kPerforceServersNeedingRenaming = (
'cn-sha-pacific1' => 'pacific',
'in-ban-perforce' => 'perforce-in',
'shelby2'         => 'nibuildtest'
);
my $gPerforceRevisionInformation = '$Id: //ComputerBasedInstruments/RF/software/rfFileIO/trunk/1.0/buildToolsRedirect.pl#1 $';
my $gPerforceClientScriptName = 'NI::P4-' .
(( $gPerforceRevisionInformation =~ m@//sa/ss/toolchain/PerlLib/export/[^/]+/([^/]+)/tools/allos/allproc/NI/P4\.pm#@ and $1 ) or
( $gPerforceRevisionInformation =~ m@//sa/ss/toolchain/PerlLib/trunk/([^/]+)/source/allos/allproc/NI/P4\.pm#(\d+)@ and "$1-#$2" ) or
'dev');
my $gModuleP4CmdVerbose = 0;
my $gP4ModuleDebugEnabled = 0;
my $gP4ModuleAvailable = 0;
our %gPerforceServerInformation;  # printed by NI::IO's mxDie
our @gPerforceOperationsHistory;  # printed by NI::IO's mxDie
my $gPerforceOperationsHistoryLength = 4;
my %gResolvedPathsCache;
my %gExportedZipFileInfoCache;
my $gNoPerforceAccess = 0;
my $gPerforceServerConnectionCount = 0;
my %gExportLocationsHash;
my $gObtainedInfoForDefaultPerforceServer = 0;
my %gP4Options;
my $gDoOneTimePerforceSetup = 1;
my %gKnownFileServerPaths;
my $gP4RetryTimeLimit = 0;
my $gP4RetryAllowed = 1;   #  Set to false by INIT if the needed Perl modules can't be imported.
my $gModuleVerbose = $::gModuleVerbose;
{
my $trace = BlockTrace->new('::INIT', $gModuleVerbose);
my $verbose = _getEnvValue( "niToolchainVerbose" );
if( defined $verbose )
{
$gModuleP4CmdVerbose = 1 if ( $verbose =~ /\bP4\b/i );
if ( $verbose =~ /\bP4Module(?:=(\d+))?\b/i )
{
$gP4ModuleDebugEnabled = 1;
$gP4ModuleDebugEnabled = $1 if defined $1;
}
}
setPerforceOperationsHistoryLength( _getEnvValue( 'nibuild_perforceOperationsHistoryLength' ) );
if( _getEnvValue( 'nibuild_noPerforceAccess' ) )
{
::logStr( "Will not access any Perforce server.", $gModuleVerbose );
$gNoPerforceAccess = 1;
}
eval
{
require POSIX;
require Time::HiRes;
import Time::HiRes qw( gettimeofday tv_interval );
};
if( $@ )
{
$gP4RetryAllowed = 0;
::logStr( "unable to load the needed Perl modules. the Perforce connection " .
"retry feature will be disabled.  Perl message: $@\n", $gModuleVerbose );
}
my $retryTime = _getEnvValue( "nibuild_perforceConnectionRetryTime" );
if( defined $retryTime )
{
::logStr( "setting the global Perforce retry time to $retryTime minutes", $gModuleVerbose );
setPerforceConnectionRetryTime( $retryTime );
}
}
my $END = sub
{
if( $gP4ModuleAvailable && $gPerforceServerConnectionCount )
{
::logStr "END: cleanup '$gPerforceServerConnectionCount' Perforce connections", $gModuleVerbose;
foreach my $serverName ( keys %gPerforceServerInformation )
{
if( exists $gPerforceServerInformation{$serverName}{P4Handle} )
{
foreach my $clientspec ( keys %{ $gPerforceServerInformation{$serverName}{P4Handle} } )
{
my $p4 = $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
::logStr "  p4->Disconnect()  ($gPerforceServerConnectionCount)  [$serverName, $clientspec]", $gModuleP4CmdVerbose;
$p4->Disconnect();
delete $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
$gPerforceServerConnectionCount--;
}
}
}
if( $gPerforceServerConnectionCount )
{
::logStr "Not all Perforce server connections that were created during " .
"the life of this script were cleaned up. This is odd. " .
"'$gPerforceServerConnectionCount' connections remain.", $gModuleVerbose;
}
}
};
push @gENDs, $END;
Python::Import('atexit')->register($END) if(%Python::Object::);
sub _getEnvValue( $ )
{
my $key = shift;
my $value = $ENV{$key};
my $output;
if( defined $value )
{
$output = "env variable '$key' = '$value'";
}
else
{
$output = "env variable '$key' is not defined";
}
::logStr( $output, 1 ) if $gModuleVerbose;
$::gEnvironmentInfo .= "$output\n";
return $value;
}
sub setPerforceOperationsHistoryLength( $ )
{
my $length = shift;
if( defined $length )
{
$gPerforceOperationsHistoryLength = abs($length);
::logStr( "perforce operations history length = $gPerforceOperationsHistoryLength", $gModuleVerbose);
}
else
{
::logStr( "perforce operations history length is unchanged ($gPerforceOperationsHistoryLength)", $gModuleVerbose);
}
return $gPerforceOperationsHistoryLength;
}
sub setPerforceConnectionRetryTime( $ )
{
my $retryTimeLimit = shift;
my $trace = BlockTrace->new( "NI::P4::setPerforceConnectionRetryTime" .
"( $retryTimeLimit )", $gModuleVerbose );
if( $retryTimeLimit && $gP4RetryAllowed )
{
$gP4RetryTimeLimit = $retryTimeLimit;
::logStr "enabled Perforce connection error retries", $gModuleVerbose;
return 1;
}
elsif( $retryTimeLimit && !$gP4RetryAllowed )
{
mxWarn "Warning: The Perforce connection retry feature cannot be used at " .
"this time.  Some required Perl modules were not found.";
}
$gP4RetryTimeLimit = 0;
::logStr "disabled Perforce connection error retries", $gModuleVerbose;
return 0;
}
sub getPerforceConnectionRetryTime( )
{
return $gP4RetryTimeLimit;
}
sub p4Cmd( $ $ ; @ )
{
my $serverName = cleanupP4ServerName(shift);
my $command = shift;
my %options = @_;
if( exists $gP4Options{$serverName} )
{
%options = ( %{ $gP4Options{$serverName} }, %options );
}
my $trace;
if( $gModuleP4CmdVerbose )
{
$trace = BlockTrace->new( "NI::P4::p4Cmd( \"$serverName\" )", 1 );
if( scalar keys %options )
{
my $outputString = '';
::dumpHash( \%options, 1, \$outputString );
::logStr( "\%options : $outputString", 1 );
}
}
if( !exists $gPerforceServerInformation{$serverName} )
{
_updatePerforceServerInfo( $serverName );
}
mxDie "Error: The \"no server access\" flag is set for the server \"$serverName\" " .
"but for some reason this script is trying to access that server. " .
"This is either a usage error or an internal Build Services error. " .
"Contact Systems Software for help."
if( $gPerforceServerInformation{$serverName}{noServerAccess} );
my @commandArray;
if( ref($command) eq 'ARRAY' )
{
@commandArray = map { s@\b${serverName}://@//@g ? $_ : $_ } @$command;
}
else
{
$command =~ s@\b${serverName}://@//@g;
@commandArray = ::parseCommandLineIntoArray( $command );
}
my $commandLogFlag = ( $gModuleVerbose || $gModuleP4CmdVerbose ||
($::gVerboseOutputFlags & $::kMXToolsDebugLogP4Commands) );
my $clientspec;
if( $options{clientspec} )
{
$clientspec = $options{clientspec};
}
elsif( exists $gPerforceServerInformation{$serverName}{clientspec} )
{
$clientspec = $gPerforceServerInformation{$serverName}{clientspec};
}
else
{
$clientspec = $kClientDefaultPerforceClientspec;
}
my @retryTimes = qw/ 5  10  15  30  60  120  60  120  60  120  300 /;
my $retryCount = 0;
my $retryLimit = getPerforceConnectionRetryTime() * 60;
my $t0 = undef;
my $elapseTime = 0;
my $useCommandLineTool = ($gP4ModuleAvailable ? 0 : 1);
$useCommandLineTool = 1 if $options{forceCommandLineUsage};
$useCommandLineTool = 1 if $options{wantRawOutput};
$useCommandLineTool = 1 if $retryLimit;
my %lastPerforceOperation;
$lastPerforceOperation{timeBegin} = localtime();
$lastPerforceOperation{server} = $serverName;
$lastPerforceOperation{commandArray} = \@commandArray;
$lastPerforceOperation{options} = \%options;
$lastPerforceOperation{clientspec} = $clientspec;
$lastPerforceOperation{useCommandLineTool} = $useCommandLineTool;
push @gPerforceOperationsHistory, \%lastPerforceOperation;
my $p4Output = undef;
my $exception = undef;
my $passwordRetry = 0;
while( 1 )
{
my $considerRetry = undef;
eval
{
local $::gSimpleDieInsideEval = 1;
if( $retryCount || $passwordRetry )
{
$lastPerforceOperation{retryCount} = $retryCount;
$lastPerforceOperation{passwordRetry} = $passwordRetry;
::logStr "*****  retrying this Perforce command (retryCount = $retryCount, " .
"passwordRetry = $passwordRetry)", $gModuleP4CmdVerbose;
}
$p4Output = _p4Cmd_internal( $serverName, \@commandArray,
$useCommandLineTool, $commandLogFlag,
$clientspec, \%lastPerforceOperation,
%options )
};
if( $@ )
{
$exception = $@;
$considerRetry = "caught exception:\n$exception";
::logStr( $considerRetry, $gModuleP4CmdVerbose );
}
elsif( defined $gP4Err && ($gP4Err =~ /Perforce client error:/) )
{
$considerRetry = $gP4Err;
::logStr( "We received a 'Perforce client error' message. " .
"This probably means the server is down.\n$considerRetry",
$gModuleP4CmdVerbose );
}
elsif( defined $gP4Err &&
($gP4Err =~ /Perforce password \(P4PASSWD\) invalid or unset\./) )
{
::logStr( 'Perforce password not set for this server', $gModuleP4CmdVerbose );
my $dieInfo;
if( $passwordRetry++ )
{
$dieInfo = $gPerforceServerInformation{$serverName}{p4PortOriginal};
}
else
{
my $updatedP4Port = _findMatchingServerInP4TicketFile( $serverName );
if( $updatedP4Port )
{
if( defined $clientspec &&
exists $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec} )
{
my $p4 = $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
::logStr "p4->Disconnect()  ($gPerforceServerConnectionCount)  [$serverName, $clientspec]", $gModuleP4CmdVerbose;
$p4->Disconnect();
delete $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
$gPerforceServerConnectionCount--;
}
$gPerforceServerInformation{$serverName}{p4PortOriginal} =
$gPerforceServerInformation{$serverName}{p4Port};
$gPerforceServerInformation{$serverName}{p4Port} = $updatedP4Port;
}
else
{
$dieInfo = $gPerforceServerInformation{$serverName}{p4Port};
}
}
if( defined $dieInfo )
{
mxDie <<EOT
Error:
The Perforce server '$serverName' cannot be accessed because you have
a password set on that server.  Please run the following command to login
to the server and try again:
 p4 -p $dieInfo login
or you can set the environment variable P4PASSWD to contain your password
and it will be used for all Perforce operations.
See "p4 help login" and/or "p4 help passwd" for more information.
EOT
;
}
}
else
{
last;    #  We're done calling Perforce.  Exit the loop.
}
if( defined $considerRetry )
{
$lastPerforceOperation{considerRetry} = $considerRetry;
if( $retryLimit )
{
if( !defined $t0 )
{
$t0 = [Time::HiRes::gettimeofday()];
my $msg = "Error communicating with the Perforce server '" .
getPerforceServerPort($serverName) . "'\n" .
"  Reason: \"$considerRetry\"";
print STDERR "[" . localtime() . "] $msg\n";
::logStr $msg, $commandLogFlag;
::logStr "  max retry time is $retryLimit seconds (" .
getPerforceConnectionRetryTime() . " minutes)", $commandLogFlag;
}
else
{
$elapseTime = POSIX::ceil(Time::HiRes::tv_interval($t0, [Time::HiRes::gettimeofday()]));
::logStr "elapse retry time: $elapseTime seconds", $commandLogFlag;
}
my $sleepTime = $retryTimes[$retryCount++ % scalar(@retryTimes)];
if( ($sleepTime + $elapseTime) > $retryLimit )
{
$sleepTime = $retryLimit - $elapseTime;
$sleepTime = 0 if ($sleepTime < 0);
::logStr "remaining retry time: $sleepTime seconds", $commandLogFlag;
}
if( $sleepTime )
{
my ($sec,$min,$hour) = localtime();
my $timeStr = sprintf( "[%02.2d:%02.2d:%02.2d]", $hour, $min, $sec );
my $msg = "will retry this Perforce command in $sleepTime seconds";
print STDERR "$timeStr $msg\n";
::logStr $msg, $commandLogFlag;
sleep( $sleepTime );
next;
}
else
{
my $msg = "retry limit reached - could not communicate with '" .
getPerforceServerPort($serverName) . "'";
print STDERR "[" . localtime() . "] $msg\n";
::logStr $msg, $commandLogFlag;
}
}
if( $exception )
{
::logStr "an exception occurred. re-raising it.", $gModuleP4CmdVerbose;
mxDie $exception;
}
else
{
::logStr "a Perforce errror occurred. returning it.", $gModuleP4CmdVerbose;
last;
}
}
}
$lastPerforceOperation{timeEnd} = localtime();
if( scalar(@gPerforceOperationsHistory) > $gPerforceOperationsHistoryLength )
{
shift @gPerforceOperationsHistory;
}
return $p4Output;
}
sub _p4Cmd_internal( $ $ $ $ $ $ @ )
{
my $serverName = shift;
my $commandArrayRef = shift;
my $useCommandLineTool = shift;
my $commandLogFlag = shift;
my $clientspec = shift;
my $lastPerforceOperationRef = shift;
my %options = @_;
my $p4Output = undef;
$gP4RawOutput = undef;
$gP4Err = undef;
$gP4ErrNo = 0;
if( $useCommandLineTool == 0 )
{
my $p4;
my $needToOpen = 1;
if( exists $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec} )
{
my $str;
$needToOpen = 0;
$p4 = $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
if( ! $p4->IsConnected() )
{
$str = 'connection dropped';
$needToOpen = 1;
}
elsif( defined $options{username} && ($p4->GetUser() ne $options{username}) )
{
$str = 'username different';
$needToOpen = 1;
}
elsif( defined $gPerforceServerInformation{$serverName}{username} &&
($p4->GetUser() ne $gPerforceServerInformation{$serverName}{username}) )
{
$str = 'username different (2)';
$needToOpen = 1;
}
elsif( defined $options{password} && ($p4->GetPassword() ne $options{password}) )
{
::logStr 'password different', $gModuleP4CmdVerbose;
$needToOpen = 1;
}
if( $needToOpen )
{
$$lastPerforceOperationRef{reconnect} = $str;
::logStr "reconnect: $str", $gModuleP4CmdVerbose;
::logStr "p4->Disconnect()  ($gPerforceServerConnectionCount)  [$serverName, $clientspec]", $gModuleP4CmdVerbose;
$p4->Disconnect();
delete $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
$gPerforceServerConnectionCount--;
}
}
if( $needToOpen )
{
$gPerforceServerConnectionCount++;
::logStr "Creating a new P4 connection ($gPerforceServerConnectionCount)", $gModuleP4CmdVerbose;
$p4 = new P4;
if( $gP4ModuleDebugEnabled )
{
::logStr "p4->Debug( $gP4ModuleDebugEnabled )", $gModuleP4CmdVerbose;
$p4->Debug( abs($gP4ModuleDebugEnabled) );
}
::logStr "p4->SetProg( $gPerforceClientScriptName )", $gModuleP4CmdVerbose;
$p4->SetProg( $gPerforceClientScriptName );
if ( $serverName ne $kClientDefaultPerforceServer )
{
::logStr "p4->SetPort( $gPerforceServerInformation{$serverName}{p4Port} )", $gModuleP4CmdVerbose;
$p4->SetPort( $gPerforceServerInformation{$serverName}{p4Port} );
}
if( $clientspec ne $kClientDefaultPerforceClientspec )
{
::logStr "p4->SetClient( $clientspec )", $gModuleP4CmdVerbose;
$p4->SetClient( $clientspec )
}
if( defined $options{username} )
{
::logStr "p4->SetUser( $options{username} )", $gModuleP4CmdVerbose;
$p4->SetUser( $options{username} )
}
elsif( defined $gPerforceServerInformation{$serverName}{username} )
{
::logStr "p4->SetUser( $gPerforceServerInformation{$serverName}{username} )", $gModuleP4CmdVerbose;
$p4->SetUser( $gPerforceServerInformation{$serverName}{username} )
}
if( defined $options{password} )
{
::logStr "p4->SetPassword( $options{password} )", $gModuleP4CmdVerbose;
$p4->SetPassword( $options{password} )
}
$p4->Tagged( 0 ); #  we don't want tagged output.
::logStr 'p4->Connect()', $gModuleP4CmdVerbose;
$p4->Connect() or
mxDie( "Failed to connect to the Perforce server " .
"'$gPerforceServerInformation{$serverName}{p4Port}'. " .
"Please be sure your network connection is working " .
"and that the Perforce server is available." );
$gPerforceServerInformation{$serverName}{P4Handle}{$clientspec} = $p4;
}
my $flag = '';
if( defined $options{stdin} )
{
$p4->SetInput( $options{stdin} );
$flag = ', stdin';
}
::logStr "calling (module$flag) 'p4 @$commandArrayRef'  [$serverName, $clientspec]", $commandLogFlag;
my @commandOutput = $p4->Run( @$commandArrayRef );
$p4Output = join( "\n", @commandOutput ) if( @commandOutput );
if( $p4->ErrorCount() )
{
my @array = $p4->Errors();
chomp(@array);
$gP4Err .= join( "\n", @array );
$gP4ErrNo++;
}
if( $p4->WarningCount() )
{
my @array = $p4->Warnings();
chomp(@array);
$gP4Err .= join( "\n", @array );
$gP4ErrNo++;
}
if( ($serverName eq $kClientDefaultPerforceServer) ||
($clientspec eq $kClientDefaultPerforceClientspec) )
{
::logStr "p4->Disconnect()  ($gPerforceServerConnectionCount)  [$serverName, $clientspec]", $gModuleP4CmdVerbose;
$p4->Disconnect();
delete $gPerforceServerInformation{$serverName}{P4Handle}{$clientspec};
$gPerforceServerConnectionCount--;
}
}
else
{
my @p4Command = qw/ p4 -s /;
push @p4Command, '-p', $gPerforceServerInformation{$serverName}{p4Port}
unless( $serverName eq $kClientDefaultPerforceServer );
push @p4Command, '-c', $clientspec
unless( $clientspec eq $kClientDefaultPerforceClientspec );
if( defined $options{username} )
{
push @p4Command, '-u', $options{username};
}
elsif( defined $gPerforceServerInformation{$serverName}{username} )
{
push @p4Command, '-u', $gPerforceServerInformation{$serverName}{username};
}
if( defined $options{password} )
{
push @p4Command, '-P', $options{password};
}
my $flag = '';
$flag = ', stdin' if defined $options{stdin};
::logStr "calling (cmd$flag) '@p4Command @$commandArrayRef'", $commandLogFlag;
my %shellCommandOpts = (dieOnCommandFailure => 0,
printCommandOutput => 0);
$shellCommandOpts{stdin} = $options{stdin} if $options{stdin};
my ($retCode, $outputAndErrorsStr, $errCode) =
::shellCommand([@p4Command, @$commandArrayRef], %shellCommandOpts);
my @outputAndErrors = split(/\n/, $outputAndErrorsStr);
chomp($gP4RawOutput = $outputAndErrorsStr) if $options{wantRawOutput};
my $lastTag = '';
foreach my $line (@outputAndErrors)
{
$line =~ /^(?:(error|warning|info|text|exit)\d*: ?)?(.*)$/;
my $prefix = $1;
my $content = $2 || '';
if( defined $prefix )
{
if( $prefix eq 'error' || $prefix eq 'warning' )
{
$gP4Err .= "$content\n";
}
elsif( $prefix eq 'info' || $prefix eq 'text' )
{
$p4Output .= "$content\n";
}
elsif( $prefix eq 'exit' )
{
$gP4ErrNo = $content;
}
else
{
mxWarn "NI::P4::p4Cmd: Unexpected p4 output: $prefix: $content\n";
}
$lastTag = $prefix;
}
elsif( $line =~ /^(Perforce client error):/ )
{
$gP4Err .= $line;
$lastTag = $1;
}
else
{
if( $lastTag eq "info" )
{
$p4Output .= "$content\n";
}
elsif( $lastTag eq 'Perforce client error' )
{
$gP4Err .= $line;
}
else
{
mxWarn "NI::P4::p4Cmd: Unexpected p4 output: $content\n";
}
}
}
}
chomp $p4Output if defined $p4Output;
chomp $gP4Err   if defined $gP4Err;
if( $gModuleP4CmdVerbose )
{
my $output     = ( defined $p4Output     ? "\"$p4Output\""     : "(undef)" );
my $err        = ( defined $gP4Err       ? "\"$gP4Err\""       : "(undef)" );
my $rawOutput  = ( defined $gP4RawOutput ? "\"$gP4RawOutput\"" : "(undef)" );
::logStr( "-" x 21,                   1 );
::logStr( "gP4ErrNo    : $gP4ErrNo",  1 );
::logStr( "p4Output    : $output",    1 );
::logStr( "gP4Err      : $err",       1 );
::logStr( "gP4RawOutput: $rawOutput", 1 );
::logStr( "-" x 21,                   1 );
}
$$lastPerforceOperationRef{p4Output}   = $p4Output;
$$lastPerforceOperationRef{p4Err}      = $gP4Err;
$$lastPerforceOperationRef{p4ErrNo}    = $gP4ErrNo;
$$lastPerforceOperationRef{rawOutput}  = $gP4RawOutput;
return $p4Output;
}
sub _findMatchingServerInP4TicketFile( $ )
{
my $serverName = cleanupP4ServerName(shift);
my $trace = BlockTrace->new( "NI::P4::_findMatchingServerInP4TicketFile( " .
"'$serverName' )", $gModuleP4CmdVerbose );
my $p4TicketsFile;
if( ::isWindows() )
{
$p4TicketsFile = $ENV{USERPROFILE} . '/p4tickets.txt';
}
else
{
$p4TicketsFile = $ENV{HOME} . '/.p4tickets';
}
my @p4Tickets = ();
if( open TEXTFILE, "<$p4TicketsFile" )
{
::logStr "reading: $p4TicketsFile", $gModuleP4CmdVerbose;
@p4Tickets = <TEXTFILE>;
close TEXTFILE;
foreach my $line ( @p4Tickets )
{
if( $line =~ /^(([^:]+):\d+)\s*=/ )
{
my $ticketServerAndPort = $1;
my $ticketServer = $2;
::logStr "found ticket for server '$ticketServer'", $gModuleP4CmdVerbose;
my $ticketServerHostname = $ticketServer;
$ticketServerHostname =~ s/^([^\.]+)\..+$/$1/;
if( $ticketServerHostname eq $serverName )
{
::logStr "matched ($ticketServerHostname). returning '$ticketServerAndPort'", $gModuleP4CmdVerbose;
return $ticketServerAndPort;
}
}
}
::logStr "no ticket server match found", $gModuleP4CmdVerbose;
}
else
{
::logStr "can't read: $p4TicketsFile", $gModuleP4CmdVerbose;
}
return undef;
}
sub p4Command( $ ; $ )
{
my $command = shift;
my $forceCommandLineToolUse = (shift or 0);
my $trace = BlockTrace->new( '::p4Command', $gModuleVerbose);
return p4Cmd( 'perforce', $command,
forceCommandLineUsage => $forceCommandLineToolUse );
}
sub p4PathCheck( $ ; $ )
{
my $pathString = shift;
my $serverStringParam = cleanupP4ServerName(shift);
if( defined $pathString &&
$pathString =~ $kCorrectPerforcePathRegEx )
{
my $server;
if( defined $1 )
{
$server = cleanupP4ServerName($1);
if( defined $serverStringParam && ($serverStringParam ne $server) )
{
mxDie( "NI::P4::p4PathCheck - error, a server name was passed " .
"into this function (\"$serverStringParam\") but that name does not " .
"match the server name that was part of the path string passed " .
"into this function (\"$server\" from \"$pathString\"). This is " .
"probably an internal Build Services error." );
}
}
else
{
$server = (defined $serverStringParam) ? $serverStringParam : 'perforce';
}
my $perforcePath = "$server:$2";
return wantarray ? ( $perforcePath, $server, $2 ) : $perforcePath;
}
else
{
return wantarray ? ( $pathString, undef, undef ) : $pathString;
}
}
sub resolvePath
{
my $resolvedPaths = resolvePaths( shift );
return wantarray ? ($$resolvedPaths[0][0], $$resolvedPaths[0][1], $$resolvedPaths[0][2]) :
$$resolvedPaths[0][0];
}
sub resolvePaths
{
my @paths = @_;
my $trace = BlockTrace->new( "resolvePaths", $gModuleVerbose );
if( $gDoOneTimePerforceSetup && $gNoPerforceAccess )
{
::logStr( "one time Perforce setup: update info for 'perforce'", $gModuleVerbose );
_updatePerforceServerInfo( 'perforce' );
}
my @resolvedPaths = ();
my %unresolvedPerforcePaths = ();
my @unresolvedLocalPaths = ();
for my $index (0 .. $#paths)
{
my $path = $paths[$index];
mxDie 'Error: ::resolvePaths cannot be called with an undef path string'
if( !defined $path);
::logStr "given path ($index): \"$path\"", $gModuleVerbose;
$path =~ s@\\@/@g;
if( $path =~ m@/\.\.(/|$)@ )
{
$path .= "/";
while($path =~ s@/(?!\.\./)[^/]+/\.\./@/@) { };
}
my ($serverName, $depotPath);
($path, $serverName, $depotPath) = p4PathCheck( $path );
if( defined $serverName &&
!exists $gPerforceServerInformation{$serverName} )
{
_updatePerforceServerInfo( $serverName );
}
if( defined $serverName && ( $depotPath =~ m@^//(.*)$@) )
{
my $pathSubstring = $1;
::logStr "  it is a perforce path: \"$path\"", $gModuleVerbose;
if( $gPerforceServerInformation{$serverName}{nonDirectMapping} == 0 )
{
my $perforcePath = $path;
my $localPath = $gPerforceServerInformation{$serverName}{root} . $pathSubstring;
push @resolvedPaths, [$perforcePath, $localPath, $serverName];
::logStr "  local path: \"$localPath\"", $gModuleVerbose;
}
else
{
if( exists $gResolvedPathsCache{$path} )
{
push @resolvedPaths, $gResolvedPathsCache{$path};
::logStr "  nonDirectMapping, but found in cache: " .
"\"" . $gResolvedPathsCache{$path}[0] . "\", " .
"\"" . $gResolvedPathsCache{$path}[1] . "\", " .
"\"" . $gResolvedPathsCache{$path}[2] . "\"", $gModuleVerbose;
}
else
{
push @resolvedPaths, [];
push @{$unresolvedPerforcePaths{$serverName}}, [$path, $index];
::logStr "  nonDirectMapping, will resolve later", $gModuleVerbose;
}
}
}
else
{
$path = ::cleanUpPath( $path, 1 );
::logStr "  might be a local path: \"$path\"", $gModuleVerbose;
my $matched = 0;
foreach my $thisServerName (keys %gPerforceServerInformation)
{
if( $gPerforceServerInformation{$thisServerName}{nonDirectMapping} == 0 )
{
if( $path =~ $gPerforceServerInformation{$thisServerName}{rootMatchExpression} )
{
if( $path =~ m@^$gPerforceServerInformation{$thisServerName}{root}(.*)$@ )
{
my $perforcePath = p4PathCheck( "//$1", $thisServerName );
my $localPath = $path;
push @resolvedPaths, [$perforcePath, $localPath, $thisServerName];
::logStr "  matched root for server \"$thisServerName\"", $gModuleVerbose;
::logStr "  perforce path: \"$perforcePath\"", $gModuleVerbose;
$matched = 1;
last;
}
}
}
}
if( !$matched )
{
if( exists $gResolvedPathsCache{$path} )
{
push @resolvedPaths, $gResolvedPathsCache{$path};
::logStr "  didn't match any client roots, but found in cache: " .
"\"" . $gResolvedPathsCache{$path}[0] . "\", " .
"\"" . $gResolvedPathsCache{$path}[1] . "\", " .
"\"" . $gResolvedPathsCache{$path}[2] . "\"", $gModuleVerbose;
}
else
{
push @resolvedPaths, [];
push @unresolvedLocalPaths, [$path, $index];
::logStr "  didn't match any client roots, will resolve later", $gModuleVerbose;
}
}
}
}
if( scalar keys %unresolvedPerforcePaths ||
scalar @unresolvedLocalPaths )
{
::logStr "Perforce servers with paths still not matched: " .
scalar keys %unresolvedPerforcePaths, $gModuleVerbose;
foreach my $thisServerName (keys %unresolvedPerforcePaths)
{
_resolvePathsOnServer( $thisServerName,
\@resolvedPaths,
\@{$unresolvedPerforcePaths{$thisServerName}},
\@unresolvedLocalPaths );
}
if( scalar @unresolvedLocalPaths )
{
::logStr "Local paths still not matched: " . scalar @unresolvedLocalPaths, $gModuleVerbose;
_obtainInfoForDefaultPerforceServer();
my @perforceServers = keys %gPerforceServerInformation;
@perforceServers = sort {
$gPerforceServerInformation{$a}{noServerAccess} <=> $gPerforceServerInformation{$b}{noServerAccess}
or
$a cmp $b } @perforceServers;
foreach my $thisServerName ( @perforceServers )
{
next if exists $unresolvedPerforcePaths{$thisServerName};
_resolvePathsOnServer( $thisServerName,
\@resolvedPaths,
undef,
\@unresolvedLocalPaths );
last if ( scalar @unresolvedLocalPaths == 0 );
}
if( scalar @unresolvedLocalPaths )
{
my $pathsString = '';
foreach my $pathItem ( @unresolvedLocalPaths )
{
$pathsString .= "  $$pathItem[0]\n";
}
my $serversString = '';
foreach my $thisServerName ( keys %gPerforceServerInformation )
{
$serversString .= "  $gPerforceServerInformation{$thisServerName}{p4Port} " .
"(clientspec " .
"\"$gPerforceServerInformation{$thisServerName}{clientspec}\")\n";
}
mxDie "Error: Could not resolve the following paths:\n$pathsString" .
"on any of the following Perforce servers:\n$serversString\n" .
"Make sure the paths are valid and that your clientspec correctly " .
"maps this depot path to your local disk.  If these paths exists on " .
"a Perforce server that is not listed above, you need to tell the " .
"Build Services about this server by defining one more more " .
"shell environment variables, such as " .
"\"nibuild_{serverName}_clientspec\" and setting it to the name " .
"of your clientspec for that server.";
}
}
}
else
{
::logStr "all paths matched without using 'p4 where'", $gModuleVerbose;
}
return \@resolvedPaths;
}
sub _resolvePathsOnServer
{
my $serverName = cleanupP4ServerName(shift);
my $resolvedPathsRef = shift;
my $unresolvedPerforcePathsRef = shift;
my $unresolvedLocalPathsRef = shift;
my $trace = BlockTrace->new( "_resolvePathsOnServer( \"$serverName\" )",
$gModuleVerbose );
my @unresolvedPerforcePaths = ();
if( defined $unresolvedPerforcePathsRef )
{
@unresolvedPerforcePaths = @{$unresolvedPerforcePathsRef};
::logStr "server \"$serverName\" paths still not matched: " .
scalar @unresolvedPerforcePaths, $gModuleVerbose;
}
::logStr "local paths still not matched: " . scalar @{$unresolvedLocalPathsRef},
$gModuleVerbose;
my $token = "___Dependencies_pm_TOKEN";
my @perforceCommand = qw/where/;
foreach my $pathItem ( @unresolvedPerforcePaths, @{$unresolvedLocalPathsRef} )
{
push @perforceCommand, "$$pathItem[0]/$token";
}
p4Cmd( $serverName, \@perforceCommand, wantRawOutput => 1 );
my $perforceResponse = $gP4RawOutput;
$perforceResponse =~ s/^info\d*:\s*-.*\n//mg;
my @perforceResponses = split(/\n/, $perforceResponse);
foreach my $pathItem ( @unresolvedPerforcePaths )
{
my $unresolvedPath = $$pathItem[0];
my $originalIndex  = $$pathItem[1];
my $response = shift @perforceResponses;
$response = '' if !defined $response;
my $pathMatch = qr/(\S.*)[\\\/]$token/o;
if( $response =~ /^info\d*:\s*$pathMatch\s+$pathMatch\s+$pathMatch\s*$/ )
{
my $perforcePath = p4PathCheck( $1, $serverName );
my $localPath = ::cleanUpPath( $3 );
if( $unresolvedPath =~ /\*/ )
{
::logStr "unresolvedPath contains a wildcard. fixing it.", $gModuleVerbose;
$perforcePath =~ s/%%\d+/*/g;
$localPath    =~ s/%%\d+/*/g;
}
$$resolvedPathsRef[$originalIndex] = [$perforcePath, $localPath, $serverName];
$gResolvedPathsCache{$unresolvedPath} = [$perforcePath, $localPath, $serverName];
::logStr "resolved Perforce path: \"$unresolvedPath\" ($originalIndex)", $gModuleVerbose;
::logStr "  perforce path: \"$perforcePath\"", $gModuleVerbose;
::logStr "  local path: \"$localPath\"", $gModuleVerbose;
}
else
{
::logStr "While checking Perforce paths, an unexpected line was encountered. " .
"The line is \"$response\". The raw Perforce command output is:\n" .
"$gP4RawOutput", $gModuleVerbose;
my $errorText = $gP4Err;
$errorText = $response if !defined $errorText;
$errorText =~ s/[\\\/]$token//g;
mxDie "Error: Could not resolve \"$unresolvedPath\" " .
"using the server '$serverName'.  Perhaps your clientspec " .
"(\"$gPerforceServerInformation{$serverName}{clientspec}\") " .
"needs to be updated to include this depot / mapping. " .
"The server reported this error:\n$errorText";
}
}
my @stillUnresolvedLocalPaths = ();
foreach my $pathItem ( @{$unresolvedLocalPathsRef} )
{
my $unresolvedPath = $$pathItem[0];
my $originalIndex  = $$pathItem[1];
my $response = shift @perforceResponses;
$response = '' if !defined $response;
my $pathMatch = qr/(\S.*)[\\\/]$token/o;
if( $response =~ /^info\d*:\s*$pathMatch\s+$pathMatch\s+$pathMatch\s*$/ )
{
my $perforcePath = p4PathCheck( $1, $serverName );
my $localPath = ::cleanUpPath( $3 );
if( $unresolvedPath =~ /\*/ )
{
::logStr "unresolvedPath contains a wildcard. fixing it.", $gModuleVerbose;
$perforcePath =~ s/%%\d+/*/g;
$localPath    =~ s/%%\d+/*/g;
}
$$resolvedPathsRef[$originalIndex] = [$perforcePath, $localPath, $serverName];
$gResolvedPathsCache{$unresolvedPath} = [$perforcePath, $localPath, $serverName];
::logStr "resolved local path: \"$unresolvedPath\" ($originalIndex)", $gModuleVerbose;
::logStr "  perforce path: \"$perforcePath\"", $gModuleVerbose;
::logStr "  local path: \"$localPath\"", $gModuleVerbose;
}
elsif( $response =~ /^error\d*:.*Perforce password.*invalid or unset/ )
{
::logStr "While checking local paths, an unexpected line was encountered. " .
"The line is \"$response\". The raw Perforce command output is:\n" .
"$gP4RawOutput", $gModuleVerbose;
my $errorText = $gP4Err;
$errorText = $response if !defined $errorText;
$errorText =~ s/[\\\/]$token//g;
mxDie "Error: Fatal error while trying to resolve \"$unresolvedPath\" " .
"using the server '$serverName':\n$errorText";
}
elsif( $response =~ /^error\d*:.+$/ )
{
::logStr "still unresolved local path: \"$unresolvedPath\" ($originalIndex)", $gModuleVerbose;
push @stillUnresolvedLocalPaths, $pathItem;
}
else
{
::logStr "While checking local paths, an unexpected line was encountered. " .
"The line is \"$response\". The raw Perforce command output is:\n" .
"$gP4RawOutput", $gModuleVerbose;
my $errorText = $gP4Err;
$errorText = "** no information **" if !defined $errorText;
$errorText =~ s/[\\\/]$token//g;
mxDie "Error: Could not resolve \"$unresolvedPath\" " .
"using the server '$serverName'.  An unexpected error was returned by " .
"the server:\n$errorText";
}
}
@{$unresolvedLocalPathsRef} = @stillUnresolvedLocalPaths;
return;
}
sub _updatePerforceServerInfo( $ )
{
my $serverName = cleanupP4ServerName(shift);
my $trace = BlockTrace->new( "_updatePerforceServerInfo( \"$serverName\" )",
$gModuleVerbose );
if( $gDoOneTimePerforceSetup )
{
my $trace2 = BlockTrace->new( "one time Perforce setup...", $gModuleVerbose );
unless( $gNoPerforceAccess )
{
my $output = `p4 -V`;
if( $? || !$output )
{
mxDie "Error: The Build Services could not locate the Perforce " .
"command-line program 'p4' in your PATH. The Perforce client " .
"tools must be installed in order to use the Build Services.";
}
else
{
chomp $output;
my $indentedOutput = $output;
$indentedOutput =~ s/^/  /gm;
my $str = "`p4 -V` returned:\n$indentedOutput";
::logStr( $str, $gModuleVerbose );
$::gEnvironmentInfo .= "$str\n";
if( $output =~ m@^\s*Rev\.\s+([^/]+)/([^/]+)/([^/]+)/([^/]+)\s+\(([^\)]+)\)\.$@m )
{
my ($app, $platform, $version, $build, $date) = ($1, $2, $3, $4, $5);
::logStr( "p4 program version: $app / $platform / $version / $build  ( $date )", $gModuleVerbose );
if( $version =~ /^(\d{4})\.(\d+)$/ )
{
my $year = $1;
if( $year < 2007 )
{
my $p4Location = `which p4`;
$p4Location = 'unknown' if !$p4Location;
chomp $p4Location;
if( ::isWindows() )
{
$p4Location =~ s@/cygdrive/([a-z])/@$1:/@;
$p4Location =~ s@/@\\@g;
}
mxDie "Perforce configuration error:\n" .
"You have a version of the Perforce command-line utility 'p4' installed\n" .
"that is too old. The Build Services requires at least version 2007.1\n" .
"You have version $version installed at \"$p4Location\"\n" .
"Please visit \"\\\\nirvana\\software\\apps\\\", download a newer version of\n" .
"the Perforce tools, install, and try again.\n";
}
}
else
{
mxWarn "Could not parse the p4 version ('$version'). Please contact Systems Software.\n";
}
}
else
{
mxWarn "Could not parse the p4 program output for its version information. Please contact Systems Software.\n";
}
}
}
}
eval
{
local $::gSimpleDieInsideEval = 1;
_updateOnePerforceServer( $serverName );
};
if( $@ )
{
::logStr "Caught an exception while checking server '$serverName':\n  '$@'", $gModuleVerbose;
::logStr "Deleting data about server '$serverName'", $gModuleVerbose;
delete $gPerforceServerInformation{$serverName};
mxDie $@;
}
if( $gDoOneTimePerforceSetup )
{
my $trace2 = BlockTrace->new( "processing additional Perforce servers listed in env vars...",
$gModuleVerbose );
my %otherServersToQuery;
if( !exists $gPerforceServerInformation{perforce} )
{
$otherServersToQuery{'perforce'} = 1;
}
foreach my $key (sort keys %ENV)
{
if( $key =~ /^nibuild_(\S+?)_(p4Port|nonDirectMapping|clientspec|root|noServerAccess|username)$/i )
{
my $matchedServerString = lc($1);
my $matchedAttribute = lc($2);
my ($thisServerName, $hadToRename) = cleanupP4ServerName($matchedServerString);
if( !exists $gPerforceServerInformation{$thisServerName} )
{
$otherServersToQuery{$thisServerName} = 1;
}
if( $hadToRename )
{
mxWarn <<EOT
You have defined the environment variable:
  nibuild_${matchedServerString}_${matchedAttribute}
The server name (${matchedServerString}) is NOT correct.
Please rename this environment variable to:
  nibuild_${thisServerName}_${matchedAttribute}
EOT
;
}
}
}
foreach my $thisServerName (sort keys %otherServersToQuery)
{
eval
{
local $::gSimpleDieInsideEval = 1;
_updateOnePerforceServer( $thisServerName );
};
if( $@ )
{
::logStr "Caught an exception while checking server '$thisServerName':\n  '$@'", $gModuleVerbose;
::logStr "Deleting data about server '$thisServerName'", $gModuleVerbose;
delete $gPerforceServerInformation{$thisServerName};
mxWarn "Warning: Unable to communicate with the Perforce server '$thisServerName'";
}
}
$gDoOneTimePerforceSetup = 0;
}
return;
}
sub cleanupP4ServerName( $ )
{
my $serverName = shift;
my $renamed = 0;
if( defined $serverName )
{
$serverName = lc($serverName);
if( exists $kPerforceServersNeedingRenaming{$serverName} )
{
my $newName = $kPerforceServersNeedingRenaming{$serverName};
::logStr "cleanupP4ServerName: remapping given name '$serverName' to '$newName'", $gModuleVerbose;
$serverName = $newName;
$renamed = 1;
}
}
return wantarray ? ( $serverName, $renamed ) : $serverName;
}
sub _updateOnePerforceServer( $ )
{
my $serverName = cleanupP4ServerName(shift);
my $trace = BlockTrace->new( "_updateOnePerforceServer( \"$serverName\" )",
$gModuleVerbose );
my $p4PortWasDefined = 0;
if( $serverName ne $kClientDefaultPerforceServer )
{
delete $gPerforceServerInformation{$serverName};
my $value = _getEnvValue( "nibuild_${serverName}_p4Port" );
if( defined $value )
{
$gPerforceServerInformation{$serverName}{p4Port} = lc($value);
$p4PortWasDefined = 1;
}
else
{
if( $serverName eq 'perforce' )
{
$gPerforceServerInformation{$serverName}{p4Port} = 'perforce.amer.corp.natinst.com:1666';
}
elsif( $serverName eq 'penguin' )
{
$gPerforceServerInformation{$serverName}{p4Port} = 'penguin.natinst.com:1666';
}
else
{
$gPerforceServerInformation{$serverName}{p4Port} = "${serverName}:1666";
}
}
$value = _getEnvValue( "nibuild_${serverName}_nonDirectMapping" );
if( defined $value )
{
if( $value eq '0' )
{
$gPerforceServerInformation{$serverName}{nonDirectMapping} = 0;
}
elsif( $value eq '1' )
{
$gPerforceServerInformation{$serverName}{nonDirectMapping} = 1;
}
else
{
mxDie( "Error: you have defined the environment variable " .
"\"nibuild_${serverName}_nonDirectMapping\" to have the value " .
"\"$value\". This is not a valid value. If defined, this variable " .
"can only be \"0\" or \"1\"." );
}
}
$value = _getEnvValue( "nibuild_${serverName}_clientspec" );
if( defined $value )
{
$gPerforceServerInformation{$serverName}{clientspec} = $value;
}
$value = _getEnvValue( "nibuild_${serverName}_root" );
if( defined $value )
{
if( ::isWindows() && ($value =~ /^[a-z]:$/i) )
{
mxDie "Error: You have defined the environment variable " .
"'nibuild_${serverName}_root' to be '$value'. This value is just " .
"the drive letter. There is no path provided. Please update this " .
"variable to include a path, such as '$value\\'.";
}
$gPerforceServerInformation{$serverName}{root} = $value;
}
$value = _getEnvValue( "nibuild_${serverName}_noServerAccess" );
if( defined $value )
{
if( $value eq '0' )
{
$gPerforceServerInformation{$serverName}{noServerAccess} = 0;
}
elsif( $value eq '1' )
{
$gPerforceServerInformation{$serverName}{noServerAccess} = 1;
}
else
{
mxDie( "Error: you have defined the environment variable " .
"\"nibuild_${serverName}_noServerAccess\" to have the value " .
"\"$value\". This is not a valid value. If defined, this variable " .
"can only be \"0\" or \"1\"." );
}
}
else
{
$gPerforceServerInformation{$serverName}{noServerAccess} = $gNoPerforceAccess;
}
$value = _getEnvValue( "nibuild_${serverName}_username" );
if( defined $value )
{
$gPerforceServerInformation{$serverName}{username} = $value;
}
}
else
{
$gPerforceServerInformation{$kClientDefaultPerforceServer}{noServerAccess} = $gNoPerforceAccess;
}
if( $gPerforceServerInformation{$serverName}{noServerAccess} == 0 )
{
my $perforceResponse = p4Cmd( $serverName, [ 'info' ] );
if( defined $perforceResponse )
{
if( $serverName eq $kClientDefaultPerforceServer )
{
if( $perforceResponse =~ /^Server address: (.+?)\s*$/m )
{
$serverName = $1;
$serverName =~ s/[\.:].*$//;
$serverName = cleanupP4ServerName($serverName);
delete $gPerforceServerInformation{$kClientDefaultPerforceServer};
::logStr "default P4 server is '$serverName'", $gModuleVerbose;
if( exists $gPerforceServerInformation{$serverName} )
{
::logStr "we already know about the default server. returning now.", $gModuleVerbose;
return;
}
::logStr "we don't yet know about this server. updating info.", $gModuleVerbose;
$gPerforceServerInformation{$serverName}{noServerAccess} = 0;
}
else
{
mxDie "Error: While trying to query for your machine's default " .
"Perforce server, the 'p4 info' query did not return " .
"the server name.";
}
}
$gPerforceServerInformation{$serverName}{p4infoResponse} = $perforceResponse;
if( $p4PortWasDefined == 0  &&
$perforceResponse =~ /^Server address: (.+?)\s*$/m )
{
my $port = $1;
$gPerforceServerInformation{$serverName}{p4Port} = $port;
::logStr "updated p4Port to be '$port'", $gModuleVerbose;
}
if( $perforceResponse =~ /^Client unknown\.\s*$/m )
{
if( $perforceResponse =~ /^Client name: (.+?)\s*$/m )
{
my $clientName = $1;
mxDie "Error: The clientspec \"$clientName\" is not defined on " .
"the Perforce server \"$serverName\". You either need to " .
"define that clientspec on this server or you need to " .
"define the shell environment variable " .
"\"nibuild_${serverName}_clientspec\" and set it to the " .
"name of the correct clientspec to use on this server.";
}
else
{
mxDie "Error: You do not have a clientspec defined on the Perforce " .
"server \"$serverName\". You either need to define a default " .
"clientspec for this server or you need to define the " .
"environment variable \"nibuild_${serverName}_clientspec\" " .
"and set it to the name of the correct clientspec.";
}
}
if( !exists $gPerforceServerInformation{$serverName}{clientspec} )
{
if( $perforceResponse =~ /^Client name: (.+?)\s*$/m )
{
my $clientName = $1;
::logStr "server returned client name '$clientName'", $gModuleVerbose;
$gPerforceServerInformation{$serverName}{clientspec} = $clientName;
}
}
if( !exists $gPerforceServerInformation{$serverName}{nonDirectMapping} ||
!exists $gPerforceServerInformation{$serverName}{root} )
{
if( $perforceResponse =~ /^Client root: (.+?)\s*$/m )
{
my $clientRoot = $1;
my $nonDirect = 0;
::logStr "server returned client root '$clientRoot'", $gModuleVerbose;
if( $clientRoot =~ /^null$/i )
{
::logStr "root is 'null'. need nonDirectMapping", $gModuleVerbose;
$nonDirect = 1;
$clientRoot = '';
}
if( !exists $gPerforceServerInformation{$serverName}{nonDirectMapping} )
{
$gPerforceServerInformation{$serverName}{nonDirectMapping} = $nonDirect;
::logStr "set nonDirectMapping to '$nonDirect'", $gModuleVerbose;
}
if( $gPerforceServerInformation{$serverName}{nonDirectMapping} )
{
$gPerforceServerInformation{$serverName}{root} = '';
::logStr "nonDirectMapping is true. forcing root to be empty", $gModuleVerbose;
}
else
{
if( !exists $gPerforceServerInformation{$serverName}{root} )
{
if( ::isWindows() && ($clientRoot =~ /^[a-z]:$/i) )
{
$clientRoot .= '\\';
::logStr "Windows: client root is just a drive letter. Adding \\", $gModuleVerbose;
mxWarn "Warning: Your $serverName clientspec is defined to be " .
"just a drive letter, without any path information. " .
"The tools will assume you mean the root of the drive " .
"( $clientRoot ), but you should update your clientspec " .
"to make this clear.";
}
$gPerforceServerInformation{$serverName}{root} = $clientRoot;
::logStr "set root to '$clientRoot'", $gModuleVerbose;
}
}
}
}
}
}
else
{
if( $gPerforceServerInformation{$serverName}{nonDirectMapping} )
{
mxDie( "Error: You have told the Build Services not to access the " .
"Perforce server '$serverName' (either by setting the shell " .
"environment variable 'nibuild_noPerforceAccess' or " .
"'nibuild_${serverName}_noServerAccess'), but you have also " .
"defined 'nibuild_${serverName}_nonDirectMapping' to true. When " .
"non-direct mapping is true, the Build Services are forced to " .
"query the server to convert Perforce paths into local filesystem " .
"paths. This combination of options cannot work together." );
}
else
{
$gPerforceServerInformation{$serverName}{nonDirectMapping} = 0;
}
if( !$gPerforceServerInformation{$serverName}{root} )
{
if( ::isWindows() && ($serverName eq "perforce") )
{
$gPerforceServerInformation{$serverName}{root} = "p:/";
mxWarn( "Warning: not all of the required Perforce server information " .
"is defined. This could mean that the server \"$serverName\" is " .
"unavailable, your clientspec is not defined correctly, or your " .
"computer is unable to resolve this DNS host name. " .
"For compatibility, since you are using the server \"perforce\", " .
"the information is being defined using the \"drive P:\" defaults. " .
"If this warning continues to occur, please contact Systems Software " .
"for help in resolving it." );
}
else
{
mxDie( "Error: You have told the Build Services not to access the " .
"Perforce server '$serverName' (either by setting the shell " .
"environment variable 'nibuild_noPerforceAccess' or " .
"'nibuild_${serverName}_noServerAccess'), but you have not " .
"defined 'nibuild_${serverName}_root'. This environment variable " .
"should be defined to point to your clientspec root directory. " .
"This information will allow the Build Services to convert " .
"Perforce paths into local filesystem paths without querying " .
"the server. Please set the variable and try again." );
}
}
if( !$gPerforceServerInformation{$serverName}{clientspec} )
{
$gPerforceServerInformation{$serverName}{clientspec} = '';
}
}
if( !exists $gPerforceServerInformation{$serverName}{p4Port}            ||
!exists $gPerforceServerInformation{$serverName}{nonDirectMapping}  ||
!exists $gPerforceServerInformation{$serverName}{clientspec}        ||
!exists $gPerforceServerInformation{$serverName}{root}              ||
!exists $gPerforceServerInformation{$serverName}{noServerAccess}     )
{
if( ::isWindows() && ($serverName eq "perforce") )
{
$gPerforceServerInformation{$serverName}{noServerAccess} = 1 if !exists $gPerforceServerInformation{$serverName}{noServerAccess};
$gPerforceServerInformation{$serverName}{root} = 'p:/' if !exists $gPerforceServerInformation{$serverName}{root};
$gPerforceServerInformation{$serverName}{nonDirectMapping} = 0 if !exists $gPerforceServerInformation{$serverName}{nonDirectMapping};
$gPerforceServerInformation{$serverName}{clientspec} = '' if !exists $gPerforceServerInformation{$serverName}{clientspec};
$gPerforceServerInformation{$serverName}{p4Port} = '' if !exists $gPerforceServerInformation{$serverName}{p4Port};
mxWarn( "Warning: not all of the required Perforce server information " .
"is defined. This could mean that the server \"$serverName\" is " .
"unavailable, your clientspec is not defined correctly, or your " .
"computer is unable to resolve this DNS host name. " .
"For compatibility, since you are using the server \"perforce\", " .
"the information is being defined using the \"drive P:\" defaults. " .
"If this warning continues to occur, please contact Systems Software " .
"for help in resolving it." );
}
else
{
mxDie( "Error: not all of the required Perforce server information is " .
"defined. This could mean that the server \"$serverName\" is unavailable, " .
"your clientspec is not defined correctly, or your " .
"computer is unable to resolve this DNS host name. " .
"Please contact Systems Software for help in this case." );
}
}
elsif( ($gPerforceServerInformation{$serverName}{nonDirectMapping} == 0) &&
($gPerforceServerInformation{$serverName}{root} eq '') )
{
mxDie( "Error: the \"nonDirectMapping\" flag is set to \"0\" for server " .
"\"$serverName\" and the clientspec root is not defined.  This is " .
"an error case. Please contact Systems Software for help in this case." );
}
$gPerforceServerInformation{$serverName}{root} =
::cleanUpPath( $gPerforceServerInformation{$serverName}{root} ) . "/";
::logStr "cleaned up root to be: '$gPerforceServerInformation{$serverName}{root}'",
$gModuleVerbose;
$gPerforceServerInformation{$serverName}{rootMatchExpression} =
qr/^$gPerforceServerInformation{$serverName}{root}/;
my $warnedForServer = 0;
foreach my $thisServerName ( keys %gPerforceServerInformation )
{
next if $thisServerName eq $serverName;
next if $gPerforceServerInformation{$thisServerName}{root} eq '';
if( $gPerforceServerInformation{$thisServerName}{root} eq
$gPerforceServerInformation{$serverName}{root} )
{
::logStr "the root for $serverName " .
"($gPerforceServerInformation{$serverName}{root}) matches " .
"the root for $thisServerName " .
"($gPerforceServerInformation{$thisServerName}{root})", $gModuleVerbose;
if( $gPerforceServerInformation{$serverName}{noServerAccess} == 1 )
{
mxWarn( "Warning: You have defined the \"nibuild_${serverName}_noServerAccess\" " .
"(or \"nibuild_noPerforceAccess\") shell environment variable " .
"but the clientspec root for the servers \"$serverName\" and " .
"\"$thisServerName\" is exactly the same.  This may be a problem " .
"for resolving local paths to Perforce paths.  Consider changing " .
"the clientspec root to be unique for each server." ) if !$warnedForServer;
$warnedForServer = 1;
}
elsif( $gPerforceServerInformation{$thisServerName}{noServerAccess} == 1 )
{
mxWarn( "Warning: You have defined the \"nibuild_${thisServerName}_noServerAccess\" " .
"(or \"nibuild_noPerforceAccess\") shell environment variable " .
"but the clientspec root for the servers \"$serverName\" and " .
"\"$thisServerName\" is exactly the same.  This may be a problem " .
"for resolving local paths to Perforce paths.  Consider changing " .
"the clientspec root to be unique for each server." );
}
else
{
_createRootMatchExpression( $serverName );
_createRootMatchExpression( $thisServerName );
}
}
}
if( $::gVerboseOutputFlags || $gModuleVerbose )
{
my $string = '';
::dumpHash( $gPerforceServerInformation{$serverName}, 1, \$string );
::logStr "gPerforceServerInformation{$serverName} : $string", $gModuleVerbose;
}
}
sub _createRootMatchExpression
{
my $serverName = cleanupP4ServerName(shift);
my $trace = BlockTrace->new( "_createRootMatchExpression( \"$serverName\" )",
$gModuleVerbose );
return if ( exists $gPerforceServerInformation{$serverName}{rootMatchExpressionIncludesDepots} );
$gPerforceServerInformation{$serverName}{rootMatchExpressionIncludesDepots} = 1;
my $perforceResponse = p4Cmd( $serverName, [ 'depots' ] );
if( $perforceResponse )
{
my @depotNames = ();
foreach my $depotLine ( split(/\n/, $perforceResponse) )
{
if( $depotLine =~ m@^Depot (\S+) \d{4}/@ )
{
push @depotNames, "$gPerforceServerInformation{$serverName}{root}$1/";
}
}
my $string = join('|', @depotNames);
$gPerforceServerInformation{$serverName}{rootMatchExpression} = qr/^($string)/;
::logStr "client root matching expression:\n" .
$gPerforceServerInformation{$serverName}{rootMatchExpression},
$gModuleVerbose;
}
else
{
mxDie "Error: Could not query the server \"$serverName\" for a list of " .
"depot names.  The server returned the error:\n$gP4Err";
}
}
sub _obtainInfoForDefaultPerforceServer( )
{
my $trace = BlockTrace->new( "_obtainInfoForDefaultPerforceServer( )", $gModuleVerbose );
if( ! $gObtainedInfoForDefaultPerforceServer )
{
$gObtainedInfoForDefaultPerforceServer = 1;
if( $gDoOneTimePerforceSetup )
{
::logStr( "one time Perforce setup: update info for 'perforce'", $gModuleVerbose );
_updatePerforceServerInfo( 'perforce' );
}
eval
{
::logStr( "obtaining info about the client's default Perforce server",
$gModuleVerbose );
_updatePerforceServerInfo( $kClientDefaultPerforceServer );
};
if( $@ )
{
::logStr( "caught an exception from _updatePerforceServerInfo() for " .
"the default server. the error was:\n$@\n----\n" .
"Ignoring the error.", $gModuleVerbose );
}
delete $gPerforceServerInformation{$kClientDefaultPerforceServer};
}
return;
}
sub getPerforceServerPort( $ )
{
my $serverName = cleanupP4ServerName(shift);
if( !exists $gPerforceServerInformation{$serverName} )
{
_updatePerforceServerInfo( $serverName );
}
return $gPerforceServerInformation{$serverName}{p4Port};
}
sub getPerforceServerClientspec( $ )
{
my $serverName = cleanupP4ServerName(shift);
if( !exists $gPerforceServerInformation{$serverName} )
{
_updatePerforceServerInfo( $serverName );
}
return $gPerforceServerInformation{$serverName}{clientspec};
}
sub getPerforceServerTime( $ )
{
my $serverName = cleanupP4ServerName(shift);
my $trace = BlockTrace->new( "getPerforceServerTime( '$serverName' )", $gModuleVerbose );
my $p4Output = p4Cmd($serverName, ['info']);
if( $gP4Err )
{
mxDie "getPerforceServerTime('$serverName'): `p4 info` failed: $gP4Err";
}
$p4Output =~ m@^Server date:\s+(\d\d\d\d/\d\d/\d\d)[ :](\d\d:\d\d:\d\d) ([-+]?\d+) (.*)$@m
or mxDie "getPerforceServerTime('$serverName'): `p4 info` didn't return a valid 'Server date' field. " .
"Try installing a new version of the p4 commandline tool. " .
"FYI, the `p4 info` output was:\n$p4Output";
my ($date, $time, $gmtOffset, $timezoneName) = ($1, $2, $3, $4);
::logStr "date       : $date", $gModuleVerbose;
::logStr "time       : $time", $gModuleVerbose;
::logStr "gmt offset : $gmtOffset", $gModuleVerbose;
::logStr "tz name    : $timezoneName", $gModuleVerbose;
return wantarray ? ($date, $time, $gmtOffset, $timezoneName) : "$date:$time";
}
sub isPerforceServerAvailable( ; $ )
{
my $serverName = cleanupP4ServerName(shift);
if( $gNoPerforceAccess )
{
return 0;
}
elsif( defined $serverName )
{
if( !exists $gPerforceServerInformation{$serverName} )
{
_updatePerforceServerInfo( $serverName );
}
if( $gPerforceServerInformation{$serverName}{noServerAccess} )
{
return 0;
}
}
return 1;
}
sub getKnownPerforceServersList
{
return sort keys %gPerforceServerInformation;
}
sub _getDepotNameString( $ )
{
my ($perforcePath, $serverName, $depotPath) = p4PathCheck( shift );
my $depotNameOnly = $depotPath;
$depotNameOnly =~ s@^(//[^/]+).*$@$1@;
my $depotName = p4PathCheck( $depotNameOnly, $serverName );
return wantarray ? ( $depotName, $depotNameOnly, $serverName ) : $depotName;
}
sub _readExportLocationFile( $ $ $ )
{
my $depotName = _getDepotNameString( shift );
my $exportLocationHashRef = shift;
my $mirrorDataHashRef = shift;
my $trace = BlockTrace->new("_readExportLocationFile( $depotName )",
$gModuleVerbose);
my %fileDataHash = ();
my $readFile = 0;
my $perforcePath = "$depotName/exportLocation";
my @lines = readP4FileBySyncOrPrint( $perforcePath );
if( @lines )
{
%fileDataHash = _parseExportLocationFileData( \@lines,
1,
$perforcePath
);
$readFile = 1;
}
else
{
::logStr "$perforcePath does NOT exist or we can't access Perforce.", $gModuleVerbose;
}
::logStr "Filling in pattern match data...", $gModuleVerbose;
foreach my $server ( keys %fileDataHash )
{
if( exists $fileDataHash{$server}{matchRegexStrings} )
{
my $pattern = join( '|', @{$fileDataHash{$server}{matchRegexStrings}} );
$$exportLocationHashRef{$server}{matchRegex} = qr/^(?:$pattern)$/;
::logStr "  [$server] matchRegex = $$exportLocationHashRef{$server}{matchRegex}", $gModuleVerbose;
if( exists $fileDataHash{$server}{exclusionRegexStrings} )
{
my $pattern = join( '|', @{$fileDataHash{$server}{exclusionRegexStrings}} );
$$exportLocationHashRef{$server}{exclusionRegex} = qr/^(?:$pattern)$/;
::logStr "  [$server] exclusionRegex = $$exportLocationHashRef{$server}{exclusionRegex}", $gModuleVerbose;
}
else
{
$$exportLocationHashRef{$server}{exclusionRegex} = qr/^$/;
::logStr "  [$server] exclusionRegex forced to $$exportLocationHashRef{$server}{exclusionRegex}", $gModuleVerbose;
}
if( exists $fileDataHash{$server}{nfsPath} )
{
$$exportLocationHashRef{$server}{main}{nfsPath} = $fileDataHash{$server}{nfsPath};
::logStr "  [$server] nfsPath = $$exportLocationHashRef{$server}{main}{nfsPath}", $gModuleVerbose;
}
if( exists $$mirrorDataHashRef{$server}{sharePathMirror} )
{
$$exportLocationHashRef{$server}{mirror}{exportLocation} = $$mirrorDataHashRef{$server}{sharePathMirror};
::logStr "  [$server] sharePathMirror = $$exportLocationHashRef{$server}{mirror}{exportLocation}", $gModuleVerbose;
}
if( exists $$mirrorDataHashRef{$server}{nfsPathMirror} )
{
$$exportLocationHashRef{$server}{mirror}{nfsPath} = $$mirrorDataHashRef{$server}{nfsPathMirror};
::logStr "  [$server] nfsPathMirror = $$exportLocationHashRef{$server}{mirror}{nfsPath}", $gModuleVerbose;
}
}
elsif( exists $fileDataHash{$server}{exclusionRegexStrings} )
{
mxWarn "The file \"$perforcePath\" contains exclusions for the file server " .
"\"$server\" but no 'match' patterns.  No exports will be found " .
"on this file server.  This is probably an error in the " .
"exportLocation file or (less likely) you need to update to a newer " .
"version of the Build Services.\n";
}
}
return $readFile;
}
sub _parseExportLocationFileData( $ $ $ )
{
my $fileLinesArrayRef = shift;
my $parsingActualExportLocationFile = shift;
my $filePerforcePath = shift;
my $trace = BlockTrace->new("_parseExportLocationData( " .
"'$filePerforcePath', " .
"$parsingActualExportLocationFile )",
$gModuleVerbose);
my %fileDataHash = ();
my $lineNumber = 0;
my $exportLocationState = 0;
my $serverString;
my $warned = 0;
foreach my $line ( @{$fileLinesArrayRef} )
{
$lineNumber++;
chomp $line;
next if( $line =~ /^\s*(?:#.*)?$/ );
if( ($exportLocationState == 0) &&
($line =~ /^\s*exportLocation\s+(\S+|\"[^"]*\")\s*$/) )
{
$serverString = $1;
$serverString =~ s/^\"(.*)\"$/$1/;
$exportLocationState = 1;
::logStr "[$lineNumber] Server: \"$serverString\"", $gModuleVerbose;
}
elsif( ($exportLocationState == 1) &&
($line =~ /^\s*{\s*$/) )
{
$exportLocationState = 2;
}
elsif( ($exportLocationState == 2) &&
($parsingActualExportLocationFile) &&
($line =~ /^\s*depotPath\s*=\s*(\S+|\"[^"]*\");\s*$/) )
{
my $path = $1;
my $exclusion = 0;
$path =~ s/^\"(.*)\"$/$1/;
if( $path =~ s@^-//@//@ )
{
$exclusion = 1;
}
my $originalPath = $path;
my $depotOnlyString     = (_getDepotNameString( $filePerforcePath ))[1];
my $thisDepotOnlyString = (_getDepotNameString( $path ))[1];
if( $thisDepotOnlyString ne $depotOnlyString )
{
mxWarn "The file \"$filePerforcePath\" contains the directive \"$line\" on " .
"line $lineNumber.  This directive's value does not begin " .
"with the expected depot name ($depotOnlyString). " .
"This is probably an error in the exportLocation file " .
"or (less likely) you need to update to a newer " .
"version of the Build Services\n";
next;
}
$path =~ s@\*@[^/]*@g;
$path =~ s@\.\.\.@.*@g;
$path =~ s@/\.\*$@(?:/.*)?@;
$path =~ s@\.(?!\*)@\\.@g;
if( $exclusion )
{
push @{$fileDataHash{$serverString}{exclusionRegexStrings}}, "(?:$path)";
::logStr "[$lineNumber] exclusion: \"$originalPath\"  [\"$path\"]", $gModuleVerbose;
}
else
{
push @{$fileDataHash{$serverString}{matchRegexStrings}}, "(?:$path)";
::logStr "[$lineNumber] match: \"$originalPath\"  [\"$path\"]", $gModuleVerbose;
}
}
elsif( ($exportLocationState == 2) &&
($parsingActualExportLocationFile) &&
($line =~ /^\s*depotPath\s*(=|!)~\s*(\S+|\"[^"]*\");\s*$/) )
{
my $type = $1;
my $path = $2;
$path =~ s/^\"(.*)\"$/$1/;
if( $type eq "!" )
{
push @{$fileDataHash{$serverString}{exclusionRegexStrings}}, "(?:$path)";
::logStr "[$lineNumber] exclusion regex: \"$path\"", $gModuleVerbose;
}
else
{
push @{$fileDataHash{$serverString}{matchRegexStrings}}, "(?:$path)";
::logStr "[$lineNumber] match regex: \"$path\"", $gModuleVerbose;
}
}
elsif( ($exportLocationState == 2) &&
($parsingActualExportLocationFile) &&
($line =~ /^\s*nfsPath\s*=\s*(\S+|\"[^"]*\");\s*$/) )
{
my $nfsPath = $1;
$nfsPath =~ s/^\"(.*)\"$/$1/;
if( exists $fileDataHash{$serverString}{nfsPath} )
{
mxWarn "The file \"$filePerforcePath\" contains the directive \"$line\" on " .
"line $lineNumber.  This is the second nfsPath directive " .
"in this exportLocation section.  Only one nfsPath directive " .
"is allowed per exportLocation section.  The first one will be " .
"used and all subsequent one(s) will be ignored. You should " .
"probably updated this file to only list one nfsPath on this " .
"exportLocation section.\n";
}
else
{
$fileDataHash{$serverString}{nfsPath} = $nfsPath;
::logStr "[$lineNumber] NFS sharePath: \"$nfsPath\"", $gModuleVerbose;
}
}
elsif( ($exportLocationState == 2) &&
($parsingActualExportLocationFile == 0) &&
($line =~ /^\s*sharePathMirror\s*=\s*(\S+|\"[^"]*\");\s*$/) )
{
my $path = $1;
$path =~ s/^\"(.*)\"$/$1/;
if( exists $fileDataHash{$serverString}{sharePathMirror} )
{
mxWarn "The file \"$filePerforcePath\" contains the directive \"$line\" on " .
"line $lineNumber.  This is the second sharePathMirror directive " .
"in this exportLocation section.  Only one directive " .
"is allowed per exportLocation section.  The first one will be " .
"used and all subsequent one(s) will be ignored. You should " .
"updated this file to only list one sharePathMirror on this " .
"exportLocation section.\n";
}
else
{
$fileDataHash{$serverString}{sharePathMirror} = $path;
::logStr "[$lineNumber] sharePathMirror: \"$path\"", $gModuleVerbose;
}
}
elsif( ($exportLocationState == 2) &&
($parsingActualExportLocationFile == 0) &&
($line =~ /^\s*nfsPathMirror\s*=\s*(\S+|\"[^"]*\");\s*$/) )
{
my $path = $1;
$path =~ s/^\"(.*)\"$/$1/;
if( exists $fileDataHash{$serverString}{nfsPathMirror} )
{
mxWarn "The file \"$filePerforcePath\" contains the directive \"$line\" on " .
"line $lineNumber.  This is the second nfsPathMirror directive " .
"in this exportLocation section.  Only one directive " .
"is allowed per exportLocation section.  The first one will be " .
"used and all subsequent one(s) will be ignored. You should " .
"updated this file to only list one nfsPathMirror on this " .
"exportLocation section.\n";
}
else
{
$fileDataHash{$serverString}{nfsPathMirror} = $path;
::logStr "[$lineNumber] nfsPathMirror: \"$path\"", $gModuleVerbose;
}
}
elsif( ($exportLocationState == 2) &&
($line =~ /^\s*}\s*$/) )
{
$exportLocationState = 0;
}
else
{
::logStr "[$lineNumber] ignoring this line", $gModuleVerbose;
if( !$warned )
{
$warned = 1;
mxWarn "The file \"$filePerforcePath\" contains the directive \"$line\" on " .
"line $lineNumber.  This directive is not recognized by this " .
"version of the Build Services.  This is either an error in " .
"the exportLocation file or you should update to a newer " .
"version of the Build Services.  This warning will not repeat " .
"for other unknown lines in this file.\n";
}
}
}
return %fileDataHash;
}
sub _readFileServerMirrorsFile( )
{
my $trace = BlockTrace->new("_readFileServerMirrorsFile( )",
$gModuleVerbose);
my %emptyHash = ();
my @lines;
my $mirrorsConfigFile = _getEnvValue( 'nibuild_fileServerMirrors' );
if( defined $mirrorsConfigFile )
{
$mirrorsConfigFile =~ s@\\@/@g;
my ($perforcePath, $serverName, $depotPath) = p4PathCheck( $mirrorsConfigFile );
if( defined $serverName )
{
$mirrorsConfigFile = $perforcePath;
::logStr "nibuild_fileServerMirrors is a Perforce path: $mirrorsConfigFile", $gModuleVerbose;
@lines = readP4FileBySyncOrPrint( $mirrorsConfigFile );
if( ! @lines )
{
mxWarn "The 'nibuild_fileServerMirrors' file '$mirrorsConfigFile' " .
"appears to be stored on a Perforce server. The file cannot be accessed. " .
"Check to make sure you have specified the path and name correctly.\n";
}
}
else
{
$mirrorsConfigFile = ::cleanUpPath( $mirrorsConfigFile, 1 );
::logStr "nibuild_fileServerMirrors is a local path: $mirrorsConfigFile", $gModuleVerbose;
if( -f $mirrorsConfigFile )
{
::logStr "$mirrorsConfigFile exists. reading it...", $gModuleVerbose;
if( open TEXTFILE, "<$mirrorsConfigFile" )
{
@lines = <TEXTFILE>;
close TEXTFILE;
}
else
{
mxWarn "Can't open the 'nibuild_fileServerMirrors' file '$mirrorsConfigFile' for reading : $!\n";
}
}
else
{
mxWarn "The 'nibuild_fileServerMirrors' file '$mirrorsConfigFile' does not exist.\n";
}
}
if( @lines )
{
return _parseExportLocationFileData( \@lines,
0,
$mirrorsConfigFile
);
}
else
{
mxWarn "The 'nibuild_fileServerMirrors' file '$mirrorsConfigFile' is empty.\n";
}
}
return %emptyHash;
}
sub readP4FileBySyncOrPrint( $ ; @ )
{
my ($perforcePath, $serverName) = p4PathCheck(shift);
my %options = @_;
my $trace = BlockTrace->new("readP4FileBySyncOrPrint( $perforcePath, ... )", $gModuleVerbose);
if( $gModuleVerbose && scalar keys %options )
{
my $outputString = '';
::dumpHash( \%options, 1, \$outputString );
::logStr( "\%options : $outputString", 1 );
}
my @lines = ();
my $tryReadingLocalFile = 0;
my $localPath;
if( $options{readLocalFileFirst} )
{
$tryReadingLocalFile = 1;
$localPath = $options{readLocalFileFirst};
::logStr( "try local path first: $localPath", $gModuleVerbose );
}
else
{
eval
{
(undef, $localPath) = resolvePath( $perforcePath );
if( isPerforceServerAvailable( $serverName ) )
{
for( my $loop = 0 ; $loop < 2 ; $loop++ )
{
next if $options{forceSync} && $loop == 0;
$tryReadingLocalFile = 0;
my @command = qw( sync );
push @command, '-f' if( $loop == 1 );
push @command, $perforcePath;
my $p4Output = p4Cmd( $serverName, \@command );
if( defined $gP4Err &&
( $gP4Err !~ / - file\(s\) up-to-date/ ) &&
( $gP4Err !~ / - no such file\(s\)\./ ) )
{
::logStr( "[try -f then use p4 print]: error is not one of the expected ones", $gModuleVerbose );
}
elsif( defined $p4Output &&
$p4Output !~ / - (added as|updating|refreshing) / )
{
::logStr( "[try -f then use p4 print]: output is not 'added as', 'updating', or 'refreshing'", $gModuleVerbose );
}
elsif( ! -f $localPath )
{
::logStr( "[try -f then use p4 print]: local file does not exist", $gModuleVerbose );
}
else
{
$tryReadingLocalFile = 1;
last;
}
}
}
else
{
$tryReadingLocalFile = 1;
::logStr( "no Perforce access for '$serverName'. trying local file", $gModuleVerbose );
}
};
if( $@ )
{
::logStr( "Caught an exception while trying to sync the file. " .
"The error was:\n$@\n----\n" .
"Ignoring this error.", $gModuleVerbose );
::logStr( "localPath not defined. we must have died in resolvePath", $gModuleVerbose )
if( !defined $localPath );
::logStr( "Must use p4 print", $gModuleVerbose );
}
}
if( $tryReadingLocalFile  &&  defined($localPath)  &&  -f $localPath )
{
::logStr "$localPath exists. reading it...", $gModuleVerbose;
if( open(TEXTFILE, '<', $localPath) )
{
@lines = <TEXTFILE>;
close TEXTFILE;
}
else
{
::logStr( "ERROR - Can't open '$localPath' for reading : $!", $gModuleVerbose );
}
}
if( $options{readLocalFileFirst} && ! @lines )
{
::logStr( "tried reading local file first but got nothing. trying Perforce this time.", $gModuleVerbose );
my %newOptions = %options;
$newOptions{readLocalFileFirst} = 0;
return readP4FileBySyncOrPrint( $perforcePath, %newOptions );
}
if( ! @lines )
{
::logStr( "using 'p4 print' for '$perforcePath'", $gModuleVerbose );
if( isPerforceServerAvailable( $serverName ) )
{
my $p4Output = p4Cmd( $serverName, [ 'print', '-q', $perforcePath ] );
if( defined $gP4Err )
{
::logStr( "can't read the file '$perforcePath'", $gModuleVerbose );
::logStr( "  Perforce error:  $gP4Err", $gModuleVerbose );
}
elsif( !defined $p4Output )
{
::logStr( "no output when reading '$perforcePath'", $gModuleVerbose );
}
else
{
@lines = split( /\n/, $p4Output );
}
}
else
{
::logStr( "no Perforce access for '$serverName'. skipping 'p4 print'", $gModuleVerbose );
}
}
if( ! @lines  &&  defined($localPath)  &&  -f $localPath )
{
::logStr "last chance... $localPath exists. reading it...", $gModuleVerbose;
if( open(TEXTFILE, '<', $localPath) )
{
@lines = <TEXTFILE>;
close TEXTFILE;
}
else
{
::logStr( "ERROR - Can't open '$localPath' for reading : $!", $gModuleVerbose );
}
}
return @lines;
}
sub _cacheExportLocationFile( $ )
{
my ($depotName, $depotOnlyString) = _getDepotNameString( shift );
my $trace = BlockTrace->new("_cacheExportLocationFile( $depotName )",
$gModuleVerbose);
if( !exists $gExportLocationsHash{__private__}{checkedForMirrors} )
{
$gExportLocationsHash{__private__}{checkedForMirrors} = 1;
my %mirrorData = _readFileServerMirrorsFile( );
$gExportLocationsHash{__private__}{mirrorData} = \%mirrorData;
}
if( !exists $gExportLocationsHash{$depotName} )
{
::logStr "no hash entry for '$depotName'. read file.", $gModuleVerbose;
_readExportLocationFile( $depotName,
\%{$gExportLocationsHash{$depotName}},
$gExportLocationsHash{__private__}{mirrorData} );
if( $gModuleVerbose )
{
my $string = '';
::dumpHash( \%gExportLocationsHash, 1, \$string );
::logStr "\%gExportLocationsHash : $string", $gModuleVerbose;
}
}
else
{
::logStr "hash entry already exists. skip reading file.", $gModuleVerbose;
}
return $depotName;
}
sub isExportStoredOnFileServer( $ )
{
my ($perforcePath, $serverName, $depotPath) = p4PathCheck( shift );
my $trace = BlockTrace->new("isExportStoredOnFileServer( $perforcePath )",
$gModuleVerbose);
my $depotName = _cacheExportLocationFile( $perforcePath );
if( $perforcePath !~ $kExportPathMatchRegEx )
{
::logStr "export path does not match \$kExportPathMatchRegEx, so it cannot live on a file server", $gModuleVerbose;
return wantarray ? ( 0 ) : 0;
}
my $exportOnServer = 0;
foreach my $server ( keys %{$gExportLocationsHash{$depotName}} )
{
next if $server eq '__private__';
if( $depotPath =~ $gExportLocationsHash{$depotName}{$server}{matchRegex} )
{
::logStr "matched on $server", $gModuleVerbose;
if( $depotPath =~ $gExportLocationsHash{$depotName}{$server}{exclusionRegex} )
{
::logStr "excluded from $server", $gModuleVerbose;
last;
}
else
{
if( wantarray )
{
if( !exists $gExportLocationsHash{$depotName}{$server}{main}{sharePath} )
{
$gExportLocationsHash{$depotName}{$server}{depotName} = $depotName;
$gExportLocationsHash{$depotName}{$server}{main}{exportLocation} = $server;
_addUNCPathData( $gExportLocationsHash{$depotName}{$server}{main}, $server );
if( ! ::isWindows() )
{
_addNFSPathData( $gExportLocationsHash{$depotName}{$server}{main}, $server );
}
if( exists $gExportLocationsHash{$depotName}{$server}{mirror}{exportLocation} )
{
_addUNCPathData( $gExportLocationsHash{$depotName}{$server}{mirror},
$gExportLocationsHash{$depotName}{$server}{mirror}{exportLocation} );
if( ! ::isWindows() )
{
_addNFSPathData( $gExportLocationsHash{$depotName}{$server}{mirror},
$gExportLocationsHash{$depotName}{$server}{mirror}{exportLocation} );
}
}
::logStr "cached data for $gExportLocationsHash{$depotName}{$server}{main}{sharePath}", $gModuleVerbose;
if( $gModuleVerbose )
{
my $string = '';
::dumpHash( \%gExportLocationsHash, 1, \$string );
::logStr "Updated \%gExportLocationsHash : $string", $gModuleVerbose;
}
}
::logStr "export on file server", $gModuleVerbose;
return ( 1, $gExportLocationsHash{$depotName}{$server} );
}
::logStr "export on file server", $gModuleVerbose;
return 1;
}
}
}
::logStr "export in Perforce", $gModuleVerbose;
return wantarray ? ( 0 ) : 0;
}
sub _addUNCPathData( $ $ )
{
my $exportLocationRef = shift;
my $server = shift;
my $filePath = "//$server";
$filePath =~ s@:/@/@;
$filePath =~ s@/$@@;
$filePath =~ s@/@\\@g;
$$exportLocationRef{UNC} = $filePath;
$$exportLocationRef{sharePath} = $filePath;
if ( $server =~ /^([^:]+):(.+)$/ )
{
$$exportLocationRef{hostname} = $1;
$$exportLocationRef{remoteMountPoint} = $2;
$$exportLocationRef{remoteMountPoint} =~ s@/$@@;
}
else
{
mxDie "NI::P4::_addUNCPathData() : Error parsing " .
"file server information: '$server'";
}
}
sub _addNFSPathData( $ $ )
{
my $exportLocationRef = shift;
my $server = shift;
if( !exists $$exportLocationRef{nfsPath} )
{
$$exportLocationRef{nfsPath} = $server;
::logStr( "nfsPath not defined. Setting it to '$server'", $gModuleVerbose );
}
elsif( $$exportLocationRef{nfsPath} =~ /^([^:]+):(.+)$/ )
{
$$exportLocationRef{hostname} = $1;
$$exportLocationRef{remoteMountPoint} = $2;
$$exportLocationRef{remoteMountPoint} =~ s@/$@@;
}
else
{
mxDie "NI::P4::_addNFSPathData() : Error parsing " .
"file server information: '$server'";
}
my @mountLines = `mount -t nfs`;
::logStr( "`mount -t nfs` returns:\n @mountLines\n", $gModuleVerbose );
foreach my $mount (@mountLines)
{
if( $mount =~ m@^([^:]+):([^ ]+) on (\S+) .+$@ )
{
return if _checkForSharePathMatch( $exportLocationRef, $1, $2, $3,
"from `mount` command" );
}
}
if( ::isMacOSX() )
{
my $nidumpExists = `which nidump`;
if( $nidumpExists =~ m@/nidump$@ )
{
my $nidump = `nidump fstab .`;
chomp $nidump;
::logStr( "`nidump fstab .` returns:\n$nidump\n", $gModuleVerbose );
while ( $nidump =~ m@^([^:]+):([^ ]+) (\S+) nfs .+$@mg )
{
return if _checkForSharePathMatch( $exportLocationRef, $1, $2, $3,
"from `nidump` command" );
}
mxDie "Error: The system `nidump` command did not return any " .
"mount points that appear to mount the expected file " .
"server share ($$exportLocationRef{nfsPath}). " .
"In order for the Build Services to access exported files that live on " .
"a file server, you must mount the file server's share " .
"onto your local filesystem. Please use the NetInfo Manager " .
"to mount $$exportLocationRef{nfsPath} " .
"onto your local filesystem, it doesn't matter where.";
}
else
{
my $mounts = `dscl localhost readall /Search/NFS`;
::logStr( "`dscl` returns:\n$mounts\n", $gModuleVerbose );
my @mounts = split( /[\r\n]+-[\r\n]+/, $mounts);
while( $#mounts >= 0 )
{
my $mount = pop( @mounts );
my $hostname = undef;
my $remoteMountPoint = undef;
my $localMountPoint = undef;
if( $mount =~ m@[\r\n]+RecordName:[ \t]+([^:]+):([^\r\n]+)[\r\n]@ )
{
$hostname= $1;
$remoteMountPoint= $2;
}
if( $mount =~ m@[\r\n]+VFSLinkDir:[ \t]+([^\r\n]+)[\r\n]@ )
{
$localMountPoint= $1;
}
if( defined($hostname) && defined($remoteMountPoint) && defined($localMountPoint) )
{
return if _checkForSharePathMatch( $exportLocationRef,
$hostname, $remoteMountPoint, $localMountPoint,
"from `dscl` command" );
}
}
mxDie "Error: The system `dscl` command did not return any " .
"mount points that appear to mount the expected file " .
"server share ($$exportLocationRef{nfsPath}). " .
"In order for the Build Services to access exported files that live on " .
"a file server, you must mount the file server's share " .
"onto your local filesystem. Please use the Directory Utility " .
"to mount $$exportLocationRef{nfsPath} " .
"onto your local filesystem, it doesn't matter where.";
}
}
else
{
if( open TEXTFILE, "</etc/fstab" )
{
::logStr( "Checking /etc/fstab", $gModuleVerbose );
while( <TEXTFILE> )
{
if ( /^([^:]+):([^ ]+) (\S+) nfs / )
{
return if _checkForSharePathMatch( $exportLocationRef, $1, $2, $3,
"in /etc/fstab" );
}
}
close TEXTFILE;
}
mxDie "Error: The system `mount` command did not return any " .
"mount points that appear to mount the expected file " .
"server share ($$exportLocationRef{nfsPath}). " .
"The file /etc/fstab was also checked but no mount point was found. " .
"In order for the Build Services to access exported files that live on " .
"a file server, you must mount the file server's share " .
"onto your local filesystem. Please add an entry to your " .
"/etc/fstab that mounts $$exportLocationRef{nfsPath} " .
"onto your local filesystem, it doesn't matter where.";
}
}
sub _checkForSharePathMatch
{
my $exportLocationsHashEntry = shift;
my $hostname = shift;
my $remoteMountPoint = shift;
my $localMountPoint = shift;
my $foundByString = shift;
$remoteMountPoint =~ s@/$@@;
$localMountPoint  =~ s@/$@@;
return 0 unless ( $remoteMountPoint eq $$exportLocationsHashEntry{remoteMountPoint} );
if( $hostname eq $$exportLocationsHashEntry{hostname} )
{
$$exportLocationsHashEntry{sharePath} = $localMountPoint;
::logStr( "found sharePath $foundByString", $gModuleVerbose );
return 1;
}
my $expectedHostname = $$exportLocationsHashEntry{hostname};
my $actualHostname = $hostname;
$expectedHostname =~ s/^([^\.]+)\..+$/$1/;
$actualHostname   =~ s/^([^\.]+)\..+$/$1/;
if( $actualHostname eq $expectedHostname )
{
$$exportLocationsHashEntry{sharePath} = $localMountPoint;
::logStr( "found sharePath $foundByString " .
"(fuzzy hostname match: $hostname == $$exportLocationsHashEntry{hostname})", $gModuleVerbose );
return 1;
}
return 0;
}
sub constructFileServerPath( $ ; $ $ )
{
my $exportPath = shift;
my $magicCookieHashRef = shift;
my $returnWindowsUNCpath = (shift or 0);
my $trace = BlockTrace->new("constructFileServerPath( $exportPath, \{token\}, $returnWindowsUNCpath )",
$gModuleVerbose);
my ($fileUNCPath, $fileSharePath) = _getFileServerPathData( $exportPath,
$magicCookieHashRef );
my $filePath = ($returnWindowsUNCpath ? $fileUNCPath : $fileSharePath);
::logStr "returning: $filePath", $gModuleVerbose;
return $filePath;
}
sub getFileServerName( $ ; $ )
{
my $exportPath = shift;
my $magicCookieHashRef = shift;
my $trace = BlockTrace->new("getFileServerName( $exportPath )",
$gModuleVerbose);
my (undef, undef, $hostname) = _getFileServerPathData( $exportPath,
$magicCookieHashRef );
::logStr "returning: $hostname", $gModuleVerbose;
return $hostname;
}
sub _getFileServerPathData( $ $ )
{
my ($perforcePath, $serverName, $depotPath) = p4PathCheck( shift );
my $magicCookieHashRef = shift;
if( !defined $magicCookieHashRef )
{
my $flag;
($flag, $magicCookieHashRef) = isExportStoredOnFileServer( $perforcePath );
if( $flag == 0 )
{
mxDie "Usage error. This function should only be called after verifying " .
"that the given export path does exist on a file server.\n" .
" perforcePath: $perforcePath";
}
}
if( $depotPath =~ $$magicCookieHashRef{matchRegex} &&
$depotPath !~ $$magicCookieHashRef{exclusionRegex} )
{
my $uncPath    = $$magicCookieHashRef{main}{UNC};
my $sharePath  = $$magicCookieHashRef{main}{sharePath};
my $hostname   = $$magicCookieHashRef{main}{hostname};
if( exists $$magicCookieHashRef{mirror}{sharePath} )
{
my $useMirror = 0;
if( $perforcePath !~ $kExportPathMatchRegEx )
{
mxDie "Usage error. This function should only be called after verifying " .
"that the given export path does exist on a file server.\n" .
" perforcePath: $perforcePath";
}
my ($versionedPerforcePath, undef, $versionedDepotPath) = p4PathCheck( $1 );
$versionedDepotPath =~ s@^//@/@;
my $path = "$$magicCookieHashRef{mirror}{sharePath}$versionedDepotPath";
$path =~ s@\\@/@g;
::logStr "_getFileServerPathData(): mirror defined. checking '$path'", $gModuleVerbose;
if( -d $path )
{
::logStr "_getFileServerPathData(): mirror path exists. using mirror for this export.", $gModuleVerbose;
$uncPath    = $$magicCookieHashRef{mirror}{UNC};
$sharePath  = $$magicCookieHashRef{mirror}{sharePath};
$hostname   = $$magicCookieHashRef{mirror}{hostname};
}
else
{
::logStr "_getFileServerPathData(): the mirror does not contain the requested path", $gModuleVerbose;
if( !exists $$magicCookieHashRef{mirror}{issuedWarning} )
{
mxWarn "You have defined a file server mirror, but the export you are trying to " .
"access does not exist on that mirror. The main server will be used.\n" .
"  Main server  : $$magicCookieHashRef{main}{exportLocation}\n" .
"  Mirror server: $$magicCookieHashRef{mirror}{exportLocation}\n" .
"  Export path  : $versionedPerforcePath\n" .
"  Mirror definition file : " . _getEnvValue( 'nibuild_fileServerMirrors' ) . "\n";
}
elsif( !exists $$magicCookieHashRef{mirror}{issuedWarning}{$versionedPerforcePath} )
{
mxWarn "export not found on file server mirror, using main server (export = $versionedPerforcePath)\n";
}
$$magicCookieHashRef{mirror}{issuedWarning}{$versionedPerforcePath} = 1;
}
}
$depotPath =~ s@^//@/@;
my $fileUNCPath = "${uncPath}${depotPath}";
$fileUNCPath =~ s@/@\\@g;
my $fileSharePath = "${sharePath}${depotPath}";
$fileSharePath =~ s@/@\\@g if( ::isWindows() );#  \\nirvana\perforceExports\sa\ss\mxdf\export\1.9\1.9.0f0
return ($fileUNCPath, $fileSharePath, $hostname );
}
else
{
mxDie "Error: The Perforce path \"$perforcePath\" was expected to exist " .
"on a file server, but according to the exportLocation data file " .
"it does not.  This is probably due to an error in the file " .
"$$magicCookieHashRef{depotName}/exportLocation\n\n" .
"Additional data:\n" .
"  perforcePath = $perforcePath\n" .
"  depotPath = $depotPath\n" .
"  matchRegex = $$magicCookieHashRef{matchRegex}\n" .
"    matched = " . ($depotPath =~ $$magicCookieHashRef{matchRegex}) . "\n" .
"  exclusionRegex = $$magicCookieHashRef{exclusionRegex}\n" .
"    matched = " . ($depotPath =~ $$magicCookieHashRef{exclusionRegex});
}
}
sub p4Where( $ ; $ $ )
{
my $inputPath = shift;
my $isExportPath = (shift or 0);
my $skipP4PathExistsCheck = (shift or 0);
my $trace = BlockTrace->new("p4Where( $inputPath, $isExportPath, $skipP4PathExistsCheck )", $gModuleVerbose);
my %returnHash = ();
$returnHash{error} = 0;
my $perforcePath;
my $localPath;
eval
{
local $::gSimpleDieInsideEval = 1;
($perforcePath, $localPath) = resolvePath( $inputPath );
};
if( $@ )
{
my $errorText = $@;
$errorText =~ s/\n+$//;
$returnHash{error} = 1;
$returnHash{errorText} = $errorText;
$returnHash{errorMessage} = "Unable to resolve the input path.\n" .
"  Input path : $inputPath\n" .
"  Error text : $errorText";
::logStr( "Problem with resolvePath. Returning the error " .
"message: $returnHash{errorMessage}\n", $gModuleVerbose );
}
else
{
$returnHash{perforcePath} = $perforcePath;
$returnHash{perforcePathExists} = p4PathExists( $perforcePath ) unless $skipP4PathExistsCheck;
$returnHash{localPath} = $localPath;
$returnHash{localPath} =~ s@/@\\@g if ::isWindows();
$returnHash{localPathExists} = _doesWildcardPathExist( $localPath );
$returnHash{localFileSharePath} = 0;
eval
{
local $::gSimpleDieInsideEval = 1;
my ($exportOnFileServer, $exportToken) = isExportStoredOnFileServer( $perforcePath );
if( $exportOnFileServer )
{
my $localFileSharePath = constructFileServerPath( $perforcePath, $exportToken );
$returnHash{localFileSharePath} = $localFileSharePath;
$returnHash{fileSharePathExists} = _doesWildcardPathExist( $localFileSharePath );
$returnHash{exportToken} = $exportToken;
}
};
if( $@ )
{
if( $isExportPath )
{
my $errorText = $@;
$errorText =~ s/\n+$//;
$returnHash{error} = 2;
$returnHash{errorText} = $errorText;
$returnHash{errorMessage} = "Unable to test whether the input path is " .
"stored on a file server.\n" .
"  Input path    : $inputPath\n" .
"  Perforce path : $perforcePath\n" .
"  Local path    : $localPath\n" .
"  Error text    : $errorText";
::logStr( "Problem with isExportStoredOnFileServer. Returning " .
"the error message: $returnHash{errorMessage}\n", $gModuleVerbose );
$returnHash{localFileSharePath} = 0;
delete $returnHash{fileSharePathExists};
delete $returnHash{exportToken};
}
else
{
$returnHash{localFileSharePath} = 0;
delete $returnHash{fileSharePathExists};
delete $returnHash{exportToken};
$returnHash{errorCheckingFileServer} = 1;
::logStr( "Caught an exception while checking to see if '$perforcePath' " .
"is stored on a file server.", $gModuleVerbose );
::logStr( "The exception was:\n$@", $gModuleVerbose );
}
}
}
if( $gModuleVerbose )
{
my $debugString = '';
::dumpHash( \%returnHash, 1, \$debugString );
::logStr( "\%returnHash : $debugString", $gModuleVerbose );
}
return \%returnHash;
}
sub _doesWildcardPathExist
{
my $path = shift;
$path =~ s@\\@/@g;
$path =~ s@\.\.\.@*@g;
if( $path =~ m@\*@ )
{
my @match = glob $path;
return scalar(@match) ? 1 : 0;
}
else
{
return -e $path ? 1 : 0;
}
}
sub p4PathExists( $ )
{
my $inputPath = shift;
my $trace = BlockTrace->new("p4PathExists( \"$inputPath\" )");
my $returnValue = 3;
eval
{
my ($perforcePath, $serverName, $depotPath) = p4PathCheck( resolvePath( $inputPath ) );
if( isPerforceServerAvailable( $serverName ) )
{
p4Cmd( $serverName, [ 'fstat', $depotPath ] );
if( $gP4Err )
{
p4Cmd( $serverName, [ 'dirs', $depotPath ] );
if( $gP4Err )
{
::logStr( "Returning 0 for $perforcePath", $gModuleVerbose );
$returnValue = 0;
return;
}
}
::logStr( "Returning 1 for $perforcePath", $gModuleVerbose );
$returnValue = 1;
}
else
{
::logStr( "The server '$serverName' is not available. " .
"Returning 2 for $perforcePath", $gModuleVerbose );
$returnValue = 2;
}
};
if( $@ )
{
::logStr( "Caught an exception while checking to see if '$inputPath' exists.", $gModuleVerbose );
::logStr( "The exception was:\n$@", $gModuleVerbose );
::logStr( "Returning 3", $gModuleVerbose );
$returnValue = 3;
}
return $returnValue;
}
sub p4Sync( $ ; @ )
{
my $pathToSync = shift;
my %options = @_;
my $trace = BlockTrace->new("p4Sync( $pathToSync, ... )", $gModuleVerbose);
if( $gModuleVerbose &&  scalar keys %options )
{
my $outputString = '';
::dumpHash( \%options, 1, \$outputString );
::logStr( "\%options : $outputString", 1 );
}
my %returnHash = ();
$returnHash{error} = 0;
$options{forceSync}     = 0 if( ! defined $options{forceSync}     );
$options{isExportPath}  = 0 if( ! defined $options{isExportPath}  );
$options{printSyncPath} = 1 if( ! defined $options{printSyncPath} );
$options{printIndent}   = 0 if( ! defined $options{printIndent}   );
$options{unsync}        = 0;  # internal "option"
if( $pathToSync =~ s/#(none|0)$//i )
{
$options{unsync} = 1;
::logStr( "unsyning path", $gModuleVerbose );
}
my $p4WhereHashRef = p4Where( $pathToSync,
$options{isExportPath},
1
);
if( $$p4WhereHashRef{error} )
{
return $p4WhereHashRef;
}
%returnHash = %{ $p4WhereHashRef };
delete $returnHash{localPathExists};
delete $returnHash{fileSharePathExists};
if( $$p4WhereHashRef{localFileSharePath} )
{
_p4SyncNetworkPath( $p4WhereHashRef, \%options, \%returnHash );
}
else
{
_p4SyncPerforcePath( $p4WhereHashRef, \%options, \%returnHash );
}
if( $options{unsync} )
{
$returnHash{sync} = 0;
}
else
{
$returnHash{sync} = 1;
}
if( $gModuleVerbose )
{
my $debugString = '';
::dumpHash( \%returnHash, 1, \$debugString );
::logStr( "p4Sync return hash: $debugString", $gModuleVerbose );
}
return \%returnHash;
}
sub _p4SyncPerforcePath( $ $ $ )
{
my $p4WhereHashRef = shift;
my $optionsHashRef = shift;
my $returnHashRef  = shift;
my $pathToSync = $$p4WhereHashRef{perforcePath};
my $trace = BlockTrace->new( "_p4SyncPerforcePath( $pathToSync, ... )",
$gModuleVerbose );
my $forceSync     = $$optionsHashRef{forceSync};
my $printSyncPath = $$optionsHashRef{printSyncPath};
my $printIndent   = $$optionsHashRef{printIndent};
my $unsync        = $$optionsHashRef{unsync};
my $syncingText = 'Syncing';
my @command = qw/ sync /;
if( $forceSync )
{
$syncingText = 'Force-syncing';
push @command, '-f';
}
if( $printSyncPath )
{
if( $unsync )
{
$syncingText = ($forceSync ? 'Force-unsyncing' : 'Unsyncing' );
}
if( $printIndent )
{
$syncingText = " " x $printIndent . $syncingText;
}
::printStr( "$syncingText $pathToSync" );
}
$pathToSync .= '#none' if( $unsync );
push @command, $pathToSync;
my $perforceServer = (p4PathCheck($pathToSync))[1];
my $perforceResponse;
eval
{
local $::gSimpleDieInsideEval = 1;
$perforceResponse = p4Cmd( $perforceServer, \@command );
};
if( $@ )
{
my $errorText = $@;
$errorText =~ s/\n+$//;
$$returnHashRef{error} = 'p4SyncDied';
$$returnHashRef{errorText} = $errorText;
$$returnHashRef{errorMessage} = "Error while executing \"p4 sync\".\n" .
"  Command    : p4 @command\n" .
"  Error text : $errorText";
::logStr( "Problem with p4Cmd. Returning the error " .
"message: $$returnHashRef{errorMessage}\n", $gModuleVerbose );
return;
}
$$returnHashRef{perforceOutput} = "";
$$returnHashRef{perforceError}  = "";
if( $gP4Err )
{
my $p4Error = $gP4Err;
$$returnHashRef{perforceError} = $p4Error;
$p4Error =~ s/\n+/\n/gs;
$p4Error =~ s/^\s+|\s+$//gs;
if( $p4Error !~ /^\s+$/ )
{
if( $p4Error =~ /not in client view/ )
{
$$returnHashRef{error} = 'notInClientView';
$$returnHashRef{errorText} = $p4Error;
$$returnHashRef{errorMessage} =
"Perforce error while syncing the requested path.\n" .
"Additional Perforce clientspec mappings are needed in your\n" .
"'$perforceServer' clientspec (" . getPerforceServerClientspec($perforceServer) . ").\n" .
"See the Perforce error below for more information:\n" .
"  Input path     : $pathToSync\n" .
"  Perforce error : $p4Error";
}
elsif( $p4Error =~ /no such file/ )
{
$$returnHashRef{error} = 'noSuchFile';
$$returnHashRef{errorText} = $p4Error;
$$returnHashRef{errorMessage} =
"Perforce error while syncing the requested path.\n" .
"The file(s) you requested do not exist in Perforce.\n" .
"  Input path     : $pathToSync\n" .
"  Perforce error : $p4Error";
}
elsif( $p4Error =~ /up-to-date/ )
{
$$returnHashRef{warning} = 'upToDate';
$$returnHashRef{warningText} = "files are up to date";
}
elsif( $p4Error =~ /no file\(s\) at that revision/ )
{
if( $unsync )
{
$$returnHashRef{warning} = 'noFileAtRevision';
$$returnHashRef{warningText} = "files aren't synced to your local disk";
}
else
{
$$returnHashRef{error} = 'noFileAtRevision';
$$returnHashRef{errorText} = $p4Error;
$$returnHashRef{errorMessage} =
"Perforce error while syncing the requested path.\n" .
"No files exist in Perforce at the requested revision.\n" .
"  Input path     : $pathToSync\n" .
"  Perforce error : $p4Error";
}
}
else
{
$$returnHashRef{error} = 'unknownPerforceError';
$$returnHashRef{errorText} = $p4Error;
$$returnHashRef{errorMessage} =
"An unexpected Perforce error was returned while trying to sync\n" .
"the requested input path.\n" .
"  Input path     : $pathToSync\n" .
"  Perforce error : $p4Error";
}
}
}
elsif( defined $perforceResponse )
{
if( $unsync &&
$perforceResponse =~ /- is opened for edit and can't be deleted/ )
{
$$returnHashRef{error} = 'fileOpenForEdit';
$$returnHashRef{errorText} = $perforceResponse;
$$returnHashRef{errorMessage} =
"One or more of the files that you requested to unsync cannot be removed\n" .
"because they are open for edit. Please submit or revert the file(s)\n" .
"before you unsync them.\n" .
"  Input path       : $pathToSync\n" .
"  Perforce message : $perforceResponse";
}
}
if( $perforceResponse )
{
$perforceResponse =~ s/^\s+|\s+$//gs;
$$returnHashRef{perforceOutput} = $perforceResponse;
}
}
sub _p4SyncNetworkPath( $ $ $ )
{
my $p4WhereHashRef = shift;
my $optionsHashRef = shift;
my $returnHashRef  = shift;
my $perforcePathToSync = $$p4WhereHashRef{perforcePath};
my $trace = BlockTrace->new( "_p4SyncNetworkPath( $perforcePathToSync " .
"($$p4WhereHashRef{localFileSharePath}), ... )",
$gModuleVerbose );
my $forceSync     = $$optionsHashRef{forceSync};
my $printSyncPath = $$optionsHashRef{printSyncPath};
my $printIndent   = $$optionsHashRef{printIndent};
my $unsync        = $$optionsHashRef{unsync};
my $syncingText = 'Copying';
if ($forceSync)
{
$syncingText = 'Force-copying';
}
if( $unsync )
{
$syncingText = 'Removing';
}
if( $printIndent )
{
$syncingText = " " x $printIndent . $syncingText;
}
my $exportPerforcePath;
my $exportLocalPath;
my $filesToSync;
if( $perforcePathToSync =~ $kExportPathMatchRegEx )
{
$exportPerforcePath = $1;
$filesToSync = $7;
my ($componentName, $majorMinor, $version) = ($3, $4, $5);
if( defined $filesToSync )
{
eval
{
local $::gSimpleDieInsideEval = 1;
($exportPerforcePath, $exportLocalPath) = resolvePath( $exportPerforcePath );
};
if( $@ )
{
$$returnHashRef{error} = 'resolvePathError';
$$returnHashRef{errorText} = $@;
$$returnHashRef{errorMessage}  =
"Error from ::resolvePath() while trying to convert\n" .
"the following Perforce into a local path.\n" .
"  Input path    :  $perforcePathToSync\n" .
"  Perforce path :  $exportPerforcePath\n" .
"  Error message :  $@";
return;
}
else
{
::logStr( "for component $componentName/$majorMinor/$version :", $gModuleVerbose );
::logStr( "  exportPerforcePath is '$exportPerforcePath'", $gModuleVerbose );
::logStr( "  exportLocalPath is '$exportLocalPath'", $gModuleVerbose );
::logStr( "  filesToSync is '$filesToSync'", $gModuleVerbose );
if( $filesToSync =~ m@[\#\@][^/]+$@ )
{
$$returnHashRef{error} = 'noFileAtRevision';
$$returnHashRef{errorText} = $perforcePathToSync;
$$returnHashRef{errorMessage}  =
"The input path contains a Perforce file revision specification.\n" .
"These files are stored on a file server and do not support file revisions.\n" .
"Please remove the revision specification and try again.\n" .
"  Input path : $perforcePathToSync";
return;
}
if( ($filesToSync eq '...')     || ($filesToSync eq '*') ||
($filesToSync eq 'package') || ($filesToSync eq 'announcement') || ($filesToSync eq 'buildExport.txt') )
{
my %specialOptions = %{$optionsHashRef};
$specialOptions{printSyncPath} = 1;
$specialOptions{forceSync}     = $forceSync;
_p4SyncPerforcePath( $p4WhereHashRef, \%specialOptions, $returnHashRef );
return if $$returnHashRef{error};
if( $$returnHashRef{warning} && ($$returnHashRef{warning} =~ /upToDate|noFileAtRevision/) )
{
delete $$returnHashRef{warning};
delete $$returnHashRef{warningText};
}
}
}
}
else
{
$$returnHashRef{error} = 'badPathToSync';
$$returnHashRef{errorText} = $perforcePathToSync;
$$returnHashRef{errorMessage}  =
"The input path appears to refer to an export directory, but\n" .
"it does not references any files (or wildcards) to sync.\n" .
"Check your input path and try again.\n" .
"  Input path     : $perforcePathToSync";
return;
}
}
else
{
$$returnHashRef{error} = 'badExportPath';
$$returnHashRef{errorText} = $perforcePathToSync;
$$returnHashRef{errorMessage}  =
"The input path does not match the expected export path format.\n" .
"Unable to obtain the \"export directory\" from the path you provided.\n" .
"The \"export directory\" is the perforcePath typically listed in the\n" .
"dependency section of a package file.\n" .
"  Input path     : $perforcePathToSync";
return;
}
my ($exportOnFileServer, $exportToken) = isExportStoredOnFileServer( $exportPerforcePath );
if( !$exportOnFileServer )
{
$$returnHashRef{error} = 'badFileServerMapping';
$$returnHashRef{errorText} = $perforcePathToSync;
$$returnHashRef{errorMessage}  =
"Based on your input path, this export should live on a file server.\n" .
"However, the \"export directory\" path does not appear to have a valid\n" .
"file server mapping. This may indicate an error in your exportLocation file.\n" .
"  Input path         : $perforcePathToSync\n" .
"  exportPerforcePath : $exportPerforcePath";
return;
}
if( $filesToSync =~ m@^(?:(.+)/)?([^/]+)$@ )
{
my $base = $1;
my $lastPathElement = $2;
::logStr( "base path: '$base'", $gModuleVerbose ) if defined $base;
::logStr( "lastPathElement: '$lastPathElement'", $gModuleVerbose );
my $simpleCopy;
if( (defined $base) && ($base =~ m@^$kZipFilesDirectory(/|$)@) )
{
::logStr "this sync consists only of the '$kZipFilesDirectory' hierarchy. bad request.", $gModuleVerbose;
$$returnHashRef{error} = 'badPathToSync';
$$returnHashRef{errorText} = "the input path to sync ($perforcePathToSync) is not valid";
$$returnHashRef{errorMessage}  =
"The requested path to be synced is the special '$kZipFilesDirectory' directory.\n" .
"This is an internal directory and cannot be synced to your local disk.\n" .
"  Input path         : $perforcePathToSync\n" .
"  exportPerforcePath : $exportPerforcePath";
return;
}
elsif( (defined $base) && ($base =~ m@(?:\*)|(?:\.\.\.)@) )
{
::logStr "path ($base) contains wildcards", $gModuleVerbose;
$simpleCopy = 0;
}
else
{
if( $lastPathElement =~ m@^(.+)?((?:\*)|(?:\.\.\.))(.+)?$@ )
{
if( defined $1 || defined $3 )
{
::logStr "last path element is complex ($lastPathElement)", $gModuleVerbose;
$simpleCopy = 0;
}
else
{
::logStr "last path element is a simple wildcard ($lastPathElement)", $gModuleVerbose;
$simpleCopy = 1;
}
}
else
{
::logStr "last path element does not contain a wildcard ($lastPathElement)", $gModuleVerbose;
$simpleCopy = 1;
}
}
::printStr("$syncingText $exportPerforcePath/$filesToSync") if $printSyncPath;
if( $simpleCopy )
{
_doSimpleFileOperation( $exportPerforcePath, $filesToSync,
$exportToken, $exportLocalPath, $base,
$unsync, $forceSync, $returnHashRef );
}
else
{
_doComplexFileOperation( $exportPerforcePath, $filesToSync,
$exportToken, $exportLocalPath,
$unsync, $forceSync, $returnHashRef );
}
if( !$unsync && !::isWindows() )
{
my $findCmd = "find $exportLocalPath -type d -exec chmod +w {} \\;";
::logStr "Calling: `$findCmd`", $gModuleVerbose;
my $findOutput = `$findCmd`;
::logStr " returned: $findOutput", $gModuleVerbose;
}
}
else
{
mxDie "Error: _p4SyncNetworkPath() - the filesToSync expression could not be parsed. " .
"This is probably an internal error. Please contact Systems Software.\n" .
"  perforceExportPath = $exportPerforcePath\n" .
"  filesToSync = $filesToSync\n";
}
}
sub _doSimpleFileOperation
{
my $exportPerforcePath = shift;
my $filesToSync = shift;
my $exportToken = shift;
my $exportLocalPath = shift;
my $base = shift;
my $unsync = shift;
my $forceSync = shift;
my $returnHashRef = shift;
my $trace = BlockTrace->new( "_doSimpleFileOperation", $gModuleVerbose );
my $sourcePerforcePath = "$exportPerforcePath/$filesToSync";
my $destPath = $exportLocalPath;
$destPath .= "/$base" if defined $base;
my $recursive = 0;
if( $sourcePerforcePath =~ s@\.\.\.@*@ )
{
::logStr "recursive copy", $gModuleVerbose;
$recursive = 1;
}
if( $unsync )
{
_deleteFilesFromLocalDisk( $sourcePerforcePath, $destPath,
$exportPerforcePath, $recursive,
$returnHashRef );
}
else
{
my $copiedFiles = 0;
my $exportFileServerPath = constructFileServerPath( $exportPerforcePath, $exportToken );
if( $recursive && (!defined $base) && _isDirectory("$exportFileServerPath/$kZipFilesDirectory") )
{
::logStr "this export contains zip files and this sync would include '$kZipFilesDirectory'", $gModuleVerbose;
::logStr "first copy all of the files in the main directory...", $gModuleVerbose;
$copiedFiles += _copyFilesToLocalDisk( $sourcePerforcePath, $exportToken,
$destPath, 0,
$forceSync, $returnHashRef );
return if $$returnHashRef{error};
::logStr "then recursively copy each subdir...", $gModuleVerbose;
my @dirs = getListOfDirectories( $exportPerforcePath, $exportToken, includeZipData => 0 );
foreach my $dir (sort @dirs)
{
$copiedFiles += _copyFilesToLocalDisk( "$exportPerforcePath/$dir/*", $exportToken,
"$exportLocalPath/$dir", 1,
$forceSync, $returnHashRef );
return if $$returnHashRef{error};
}
}
else
{
$copiedFiles += _copyFilesToLocalDisk( $sourcePerforcePath, $exportToken,
$destPath, $recursive,
$forceSync, $returnHashRef );
}
$copiedFiles += _copyZipFilesToLocalDisk( $exportPerforcePath, $exportToken,
$exportLocalPath, $filesToSync,
$forceSync, $returnHashRef );
if( $copiedFiles == 0 && !$$returnHashRef{error} )
{
::logStr "the source to sync ($exportPerforcePath/$filesToSync) does not exist", $gModuleVerbose;
my $fileServer = getFileServerName( $exportPerforcePath, $exportToken );
$$returnHashRef{error} = 'sourcePathDoesNotExist';
$$returnHashRef{errorText} = "the source path to sync ($exportPerforcePath/$filesToSync) does not exist";
$$returnHashRef{errorMessage}  =
"The requested path to be synced does not exist on the file server.\n" .
"There are no files to be copied. Your input path may be incorrect\n" .
"or you may not have access to the file share. Check that you have\n" .
"access to the file server and to this source directory.\n" .
"  Input path         : $exportPerforcePath/$filesToSync\n" .
"  exportPerforcePath : $exportPerforcePath\n" .
"  file server        : $fileServer\n" .
"  file server path   : $exportFileServerPath";
return;
}
}
}
sub _doComplexFileOperation
{
my $exportPerforcePath = shift;
my $filesToSync = shift;
my $exportToken = shift;
my $exportLocalPath = shift;
my $unsync = shift;
my $forceSync = shift;
my $returnHashRef = shift;
my $trace = BlockTrace->new( "_doComplexFileOperation( )", $gModuleVerbose );
my @listOfFiles = getListOfFiles( $exportPerforcePath,
$filesToSync,
$exportToken,
includeZipData => $unsync,
includeFileServerData => 1 );
my $copiedFiles = 0;
foreach my $fileToCopy ( @listOfFiles )
{
if( $fileToCopy =~ m@^(?:(.+)/)?(?:[^/]+)$@ )
{
my $path = $1;
my $destPath = "$exportLocalPath";
$destPath .= "/$path" if defined $path;
if( $unsync )
{
_deleteFilesFromLocalDisk( "$exportPerforcePath/$fileToCopy",
$destPath, $exportPerforcePath,
0,
$returnHashRef );
}
else
{
$copiedFiles += _copyFilesToLocalDisk( "$exportPerforcePath/$fileToCopy",
$exportToken, $destPath,
0,
$forceSync, $returnHashRef );
return if $$returnHashRef{error};
}
}
else
{
mxDie "Error: _p4SyncNetworkPath() - a file returned by getListOfFiles() " .
"could not be parsed. This is probably an internal error. " .
"Please contact Systems Software.\n" .
"  perforceExportPath = $exportPerforcePath\n" .
"  filesToSync = $filesToSync\n" .
"  fileToCopy = $fileToCopy\n";
}
}
return if $unsync;
$copiedFiles += _copyZipFilesToLocalDisk( $exportPerforcePath, $exportToken,
$exportLocalPath, $filesToSync,
$forceSync, $returnHashRef );
if( $copiedFiles == 0  &&  !$$returnHashRef{error} )
{
::logStr "the source to sync ($exportPerforcePath/$filesToSync) does not exist", $gModuleVerbose;
my $exportFileServerPath = constructFileServerPath( $exportPerforcePath, $exportToken );
my $fileServer = getFileServerName( $exportPerforcePath, $exportToken );
$$returnHashRef{error} = 'sourcePathDoesNotExist';
$$returnHashRef{errorText} = "the source path to sync ($exportPerforcePath/$filesToSync) does not exist";
$$returnHashRef{errorMessage}  =
"The requested path to be synced does not exist on the file server.\n" .
"There are no files to be copied. Your input path may be incorrect\n" .
"or you may not have access to the file share. Check that you have\n" .
"access to the file server and to this source directory.\n" .
"  Input path         : $exportPerforcePath/$filesToSync\n" .
"  exportPerforcePath : $exportPerforcePath\n" .
"  file server        : $fileServer\n" .
"  file server path   : $exportFileServerPath";
return;
}
}
sub _isDirectory( $ )
{
my $fileServerPath = shift;
if( exists $gKnownFileServerPaths{$fileServerPath} )
{
return $gKnownFileServerPaths{$fileServerPath};
}
else
{
my $isDirectory = (-d $fileServerPath) && !(-l $fileServerPath);
$gKnownFileServerPaths{$fileServerPath} = $isDirectory;
return $isDirectory;
}
}
sub getListOfDirectories( $ $ ; @ )
{
my ($perforcePath, $serverName, $depotPath) = p4PathCheck( shift );
my $exportToken = shift;
my %options = @_;
my $trace = BlockTrace->new("getListOfDirectories( $perforcePath )",
$gModuleVerbose);
if( $gModuleVerbose &&  scalar keys %options )
{
my $outputString = '';
::dumpHash( \%options, 1, \$outputString );
::logStr( "\%options : $outputString", 1 );
}
$options{includeZipData}         = 1 if( ! defined $options{includeZipData}         );
$options{includeFileServerData}  = 1 if( ! defined $options{includeFileServerData}  );
if( $perforcePath =~ m@(?:\*)|(?:\.\.\.)|(?:\?)@ )
{
mxDie "Error: getListOfDirectories() - the path passed into this function " .
"(\"$perforcePath\") contains one or more wildcard characters. " .
"This is NOT allowed.";
}
my @directories = ();
if( $exportToken )
{
my $fileServerPath = constructFileServerPath( $perforcePath, $exportToken );
::logStr( "export located on file server at \"$fileServerPath\"", $gModuleVerbose );
my $removeArchiveSubdir = 0;
my $exportPerforcePath;
my $exportRelativePath;
if( $perforcePath =~ $kExportPathMatchRegEx )
{
$exportPerforcePath = $1;
$exportRelativePath = $7;
$removeArchiveSubdir = 1 unless defined $exportRelativePath;
}
if( $options{includeFileServerData}  &&  opendir(DIR, $fileServerPath) )
{
@directories =  grep { !/^(?:\.|\.\.)$/  &&
( $removeArchiveSubdir ? ($_ ne $kZipFilesDirectory) : 1 ) &&
_isDirectory( "$fileServerPath/$_" ) } readdir(DIR);
closedir DIR;
}
if( $options{includeZipData}  &&  defined $exportPerforcePath )
{
_getListOfDirectoriesFromZips( constructFileServerPath( $exportPerforcePath, $exportToken ),
$exportRelativePath,
\@directories );
}
}
else
{
::logStr( "export located in Perforce", $gModuleVerbose );
my $perforceResponse = p4Cmd( $serverName,
[ 'dirs', "$depotPath/*" ] );
if($gP4Err && $gP4Err !~ /no such file/)
{
::logStr( "Unexpected Perforce response while executing 'p4 dirs'.", $gModuleVerbose );
::logStr( "   Perforce error is: $gP4Err", $gModuleVerbose );
::logStr( "   Ignoring this error.", $gModuleVerbose );
return @directories;
}
elsif(!$gP4Err)
{
my $quotedDepotPath = quotemeta($depotPath);
$perforceResponse =~ s#$quotedDepotPath/##gs;
$perforceResponse =~ s#\s+$##s;
@directories = split(/\n+/s, $perforceResponse);
}
}
::logStr( "found " . scalar @directories . " directories.", $gModuleVerbose );
::logStr( "subdirs:\n  " . join( "\n  ", @directories), $gModuleVerbose ) if $gModuleVerbose;
return @directories;
}
sub getListOfFiles( $ $ $ ; @ )
{
my ($perforceExportPath, $serverName, $depotPath) = p4PathCheck( shift );
my $relativePathToEnumerate = shift;
my $exportToken = shift;
my %options = @_;
my $trace = BlockTrace->new("getListOfFiles( " .
"$perforceExportPath, $relativePathToEnumerate )",
$gModuleVerbose);
if( $gModuleVerbose &&  scalar keys %options )
{
my $outputString = '';
::dumpHash( \%options, 1, \$outputString );
::logStr( "\%options : $outputString", 1 );
}
$options{includeZipData}         = 1 if( ! defined $options{includeZipData}         );
$options{includeFileServerData}  = 1 if( ! defined $options{includeFileServerData}  );
my @files = ();
if( $exportToken )
{
my $fileServerExportPath = constructFileServerPath( $perforceExportPath, $exportToken );
$fileServerExportPath =~ s@\\@/@g;
my $fileServerPathToEnumerate =
constructFileServerPath( "$perforceExportPath/$relativePathToEnumerate",
$exportToken );
$fileServerPathToEnumerate =~ s@\\@/@g;
$fileServerPathToEnumerate =~ s@/[^/]*(?:(?:\*)|(?:\.\.\.)).*$@@;
::logStr( "export located on file server at   : \"$fileServerExportPath\"", $gModuleVerbose );
::logStr( "base path for directory search     : \"$fileServerPathToEnumerate\"", $gModuleVerbose );
::logStr( "export-relative path pattern       : \"$relativePathToEnumerate\"", $gModuleVerbose );
my $isDirectory = _isDirectory( $fileServerPathToEnumerate );
if( $isDirectory )
{
my @relativePathPatternArray = ();
my $tripleDotIndex = -1;
my $index = 0;
foreach my $item ( split( m@/@, $relativePathToEnumerate) )
{
if( ($item =~ m@\.\.\.@) && ($tripleDotIndex == -1) )
{
$tripleDotIndex = $index;
}
$item =~ s@\.\.\.@___DOTS___@g;
$item =~ s@\.@\\.@g;
$item =~ s@\*@[^/]+@g;
$item =~ s@___DOTS___@.+@g;
push @relativePathPatternArray, $item;
$index++;
}
my $relativePathPattern = join( '/', @relativePathPatternArray );
my $relativePathPatternRegex = qr/^($relativePathPattern)$/;
::logStr( "export-relative path pattern regex : $relativePathPatternRegex", $gModuleVerbose );
::logStr( "triple dot wildcard index          : $tripleDotIndex", $gModuleVerbose );
pop @relativePathPatternArray;
if( $options{includeFileServerData} )
{
my $trace1 = BlockTrace->new("calling File::Find on \"$fileServerPathToEnumerate\"", $gModuleVerbose);
my $wantedCodeRef = sub { _collectFiles( $fileServerExportPath,
$relativePathPatternRegex,
\@relativePathPatternArray,
$tripleDotIndex,
\@files ); };
my $prevNlink = $File::Find::dont_use_nlink;
if( !::isWindows()  &&
getFileServerName( $perforceExportPath, $exportToken )
!~ /^(nirvana|hades)$/i )
{
$File::Find::dont_use_nlink = 1;
::logStr( "dont_use_nlink = 1", $gModuleVerbose );
}
find( { wanted   => $wantedCodeRef,
no_chdir => 1 },
$fileServerPathToEnumerate );
$File: //ComputerBasedInstruments/RF/software/rfFileIO/trunk/1.0/buildToolsRedirect.pl $prevNlink;
}
_getListOfFilesFromZips( $fileServerExportPath,
$relativePathPatternRegex,
\@files ) if( $options{includeZipData} );
}
else
{
if( !defined $isDirectory )
{
::logStr( "the base path does not exist. returning now.", $gModuleVerbose );
}
else
{
mxDie "Error: getListOfFiles() - the base path " .
"does not refer to a directory but instead refers to a file! " .
"This is not expected.  Please contact Systems Software.\n" .
"  perforceExportPath               : $perforceExportPath\n" .
"  export located on file server at : \"$fileServerExportPath\"\n" .
"  base path for directory search   : \"$fileServerPathToEnumerate\"\n" .
"  export-relative path pattern     : \"$relativePathToEnumerate\"\n";
}
}
}
else
{
my $p4PathToEnumerate = "$perforceExportPath/$relativePathToEnumerate";
my $perforceResponse = p4Cmd( $serverName,
[ 'files', $p4PathToEnumerate ] );
if ($gP4Err)
{
if ($gP4Err =~ /no such file/)
{
::logStr( "No files found.", $gModuleVerbose );
}
else
{
::logStr( "Unexpected Perforce response while executing 'p4 files'.", $gModuleVerbose );
::logStr( "   Perforce error is: $gP4Err", $gModuleVerbose );
::logStr( "   Ignoring this error.", $gModuleVerbose );
}
return @files;
}
foreach my $responseLine ( split(/\n/s, $perforceResponse) )
{
my $quotedDepotPath = quotemeta($depotPath);
if ($responseLine =~ m@^$quotedDepotPath/([^#]+)#(\d+) - (\w+) @)
{
my ($relativeFilePath, $revision, $lastChange) = ($1, $2, $3);
push @files, $relativeFilePath  if( $lastChange ne 'delete' );
}
elsif ($responseLine !~ /^\s*$/)
{
mxDie "Error: getListOfFiles() - Unexpected line in perforce response to 'p4 files':\n" .
"This is not expected.  Please contact Systems Software.\n" .
"  Path: $p4PathToEnumerate\n" .
"  Perforce response: $responseLine\n";
}
}
}
::logStr( "found " . scalar @files . " files.", $gModuleVerbose );
::logStr( "files:\n  " . join( "\n  ", @files), $gModuleVerbose ) if( $gModuleVerbose && scalar @files);
return @files;
}
sub _collectFiles
{
my $fileServerExportPath = shift;
my $relativePathPatternRegex = shift;
my $relativePathPatternRegexArrayRef = shift;
my $tripleDotIndex = shift;
my $collectedFilesArrayRef = shift;
if( $File: //ComputerBasedInstruments/RF/software/rfFileIO/trunk/1.0/buildToolsRedirect.pl ${fileServerExportPath}(/(.+))?$@ )
{
my $match = $1;
my $relativePath = $2;
$relativePath = '' if( !defined $match );
if( _isDirectory( $File::Find::name ) )
{
::logStr( "[directory] relative path = '$relativePath'", 1 ) if $gModuleVerbose;
if( $relativePath eq $kZipFilesDirectory )
{
::logStr( " - always skip '$kZipFilesDirectory'", 1 ) if $gModuleVerbose;
$File::Find::prune = 1;
return;
}
my $index = 0;
foreach my $item ( split( m@/@, $relativePath ) )
{
::logStr( "[$index] check '$item'", 1 ) if $gModuleVerbose;
if( ($tripleDotIndex != -1) && ($index == $tripleDotIndex) )
{
::logStr( " - tripple dot index. last", 1 ) if $gModuleVerbose;
last;
}
my $patternItem = $$relativePathPatternRegexArrayRef[$index];
if( !defined $patternItem  ||  $item !~ m@^$patternItem$@ )
{
if( $gModuleVerbose )
{
if( !defined $patternItem )
{
::logStr( " - pattern not define. prune", 1 );
}
else
{
::logStr( " - pattern not matched. prune", 1 );
}
}
$File::Find::prune = 1;
last;
}
$index++;
}
}
else
{
::logStr( "[not directory] relative path = '$relativePath'", 1 ) if $gModuleVerbose;
if( $relativePath =~ $relativePathPatternRegex )
{
::logStr( " - pattern matched. store it", 1 ) if $gModuleVerbose;
push @{$collectedFilesArrayRef}, $relativePath;
}
}
}
else
{
::logStr( "path doesn't match. bad!", 1 ) if $gModuleVerbose;
my $isDirectory = _isDirectory( $File::Find::name );
$isDirectory = "<undef>" if !defined $isDirectory;
mxDie "Error: _collectFiles(): the file system path that " .
"was enumerated does NOT match the export path location. This is an " .
"unexpected error. Please contact Systems Software.\n" .
"  File::Find::name = $File::Find::name\n" .
"  fileServerExportPath = $fileServerExportPath\n" .
"  isDirectory = $isDirectory";
}
}
sub _getListOfFilesFromZips( $ $ $ )
{
my $fileServerExportPath = shift;
my $relativePathPatternRegex = shift;
my $collectedFilesArrayRef = shift;
_processZipFiles( $fileServerExportPath,
'_getListOfFilesFromZips',
sub {
_collectZipItems( shift,
0,
shift,
$relativePathPatternRegex,
$collectedFilesArrayRef );
}
);
}
sub _getListOfDirectoriesFromZips( $ $ $ )
{
my $fileServerExportPath = shift;
my $exportRelativePath = shift;
my $collectedDirectoriesArrayRef = shift;
my $relativePathPatternRegex;
if($exportRelativePath)
{
$relativePathPatternRegex = qr@^\Q$exportRelativePath\E/([^/]+)/@;
}
else
{
$relativePathPatternRegex = qr@^([^/]+)/@;
}
_processZipFiles( $fileServerExportPath,
"_getListOfDirectoriesFromZips[ match on: $relativePathPatternRegex ]",
sub {
_collectZipItems( shift,
1,
shift,
$relativePathPatternRegex,
$collectedDirectoriesArrayRef );
}
);
}
sub _processZipFiles( $ $ $ )
{
my $fileServerExportPath = shift;
my $traceName = shift;
my $processingCallback = shift;
$fileServerExportPath =~ s@\\@/@g;
my $zipsPath = "$fileServerExportPath/$kZipFilesDirectory";
return unless _isDirectory($zipsPath);
my $trace = BlockTrace->new( $traceName, $gModuleVerbose );
if( opendir(DIR, $zipsPath) )
{
my @zips =  grep { /\.zip$/  } readdir(DIR);
closedir DIR;
foreach my $zipFile (sort @zips)
{
my $file = "$zipsPath/$zipFile";
if( ! exists $gExportedZipFileInfoCache{$file} )
{
::logStr("checking: $file", $gModuleVerbose);
my( $unzipStatus, $unzipOutput) =
::shellCommand( [ 'unzip', '-Z', '-s', $file ],
noDie => 1,
printCommandOutput => 0
);
if( $unzipStatus == 0 )
{
$gExportedZipFileInfoCache{$file} = $unzipOutput;
}
else
{
mxWarn "Unexpected exit code ($unzipStatus) from unzip for $file\n";
next;
}
}
foreach my $line ( split( /\n/, $gExportedZipFileInfoCache{$file} ) )
{
&$processingCallback( $line, $file );
}
}
}
}
sub _collectZipItems( $ $ $ $ $ )
{
my $line = shift;
my $wantDirectories = shift;
my $zipFile = shift;
my $relativePathPatternRegex = shift;
my $collectedItemArrayRef = shift;
return if( $line =~ /^Archive: /              ||
$line =~ /^Zip file size: /        ||
$line =~ /^\d+ file(s)?, \d+ bytes /  );
if( $line =~ /^ ([dlrwx-]{4}) [a-z\-]+ .+? \d\d:\d\d \s+ (.+)$/x )
{
my $mode = $1;
my $file = $2;
if( $wantDirectories )
{
return unless $mode =~ /^d/;
}
else
{
return unless $mode =~ /^-/;
}
if( $file =~ $relativePathPatternRegex )
{
my $match = $1;
unless( grep { $_ eq $match } @{$collectedItemArrayRef} )
{
push @{$collectedItemArrayRef}, $match;
if( $gModuleVerbose )
{
::logStr( "$line", 1 );
::logStr( " - pattern matched, pushing: $match", 1 );
}
}
}
}
else
{
mxWarn "Unexpected output from unzip for $zipFile\n" .
"line: `$line`\n";
}
}
sub _copyFilesToLocalDisk( $ $ $ $ $ $ )
{
my $sourcePerforcePath = shift;
my $sourceExportToken = shift;
my $destPath = shift;
my $recursive = shift;
my $forceSync = shift;
my $returnHashRef = shift;
my $trace = BlockTrace->new("_copyFilesToLocalDisk( )", $gModuleVerbose);
my $sourceFileServerPath = constructFileServerPath( $sourcePerforcePath,
$sourceExportToken );
$sourceFileServerPath =~ s@\\@/@g;
if( $sourceFileServerPath =~ m@^(?:(.+)/)([^/]+)$@ )
{
my $sourcePath = $1;
if( ! _isDirectory( $sourcePath ) )
{
::logStr "the source directory to sync from ($sourcePath) does not exist", $gModuleVerbose;
return 0;
}
}
if( ! _isDirectory( $destPath ) )
{
::logStr "the destination directory ($destPath) does not " .
"exist. creating it.", $gModuleVerbose;
eval { mkpath( $destPath, $gModuleVerbose ) };
if ($@)
{
$$returnHashRef{error} = 'mkdirError';
$$returnHashRef{errorText} = "Unable to create the local file system path \"$destPath\"";
$$returnHashRef{errorMessage}  =
"Unable to create the local file system path \"$destPath\" " .
"while trying to copy files from $sourceFileServerPath " .
"to your local disk.\n  The error was: $@\n" .
"Please correct this problem and try again.";
return 0;
}
}
if( ::isWindows() )
{
if( $sourceFileServerPath =~ m@^(?:(.+)/)([^/]+)$@ )
{
my $sourcePath = $1;
my $sourceFile = $2;
$sourcePath =~ s@/@\\@g;
$destPath =~ s@/@\\@g;
my @commandArray;
push @commandArray, "$ENV{nitoolchainMisc}/robocopy.exe",
$sourcePath, $destPath, $sourceFile;
push @commandArray, qw( /XX /COPY:DAT /A+:R /TS /FP /NP /R:1 /W:2 );
push @commandArray, '/E'    if $recursive;
push @commandArray, '/IS'   if $forceSync;
if( $gModuleVerbose ) { push @commandArray, '/V';   }
else                  { push @commandArray, '/NDL'; }
::logStr "calling: @commandArray", $gModuleVerbose;
my ($copyStatus, $copyOutput) =
::shellCommand( \@commandArray,
noDie => 1,
printCommandOutput => 0 );
chomp $copyOutput;
if( $copyStatus == -1)
{
$$returnHashRef{error} = 'fileCopyError';
$$returnHashRef{errorText} = "Exit code: -1 == The copy command died prematurely";
$$returnHashRef{errorMessage}  =
"Error while trying to copy files to your local disk.\n\n" .
"The copy command was: @commandArray\n\n" .
"The exit code was: -1\n" .
"The code means: The copy command died prematurely.";
return 0;
}
elsif( $copyStatus == 0x10 )
{
::logStr "robocopy was unable to copy any files.", $gModuleVerbose;
return 0;
}
elsif( $copyStatus & ~(0x01 | 0x02) )
{
my $hexString = sprintf( "0x%02X", $copyStatus );
my $errorString = "";
$errorString .= "Serious error. Robocopy did not copy any files.\n" .
"  This is either a usage error or an error due to\n" .
"  insufficient access privileges on the source or\n" .
"  destination directories.\n"
if ($copyStatus & 0x10);
$errorString .= "Some files or directories could not be copied\n" .
"  (copy errors occurred and the retry limit was\n" .
"  exceeded). Check these errors further.\n"
if ($copyStatus & 0x08);
$errorString .= "Some Mismatched files or directories were detected.\n" .
"  Examine the output log. Housekeeping is probably necessary.\n"
if ($copyStatus & 0x04);
$$returnHashRef{error} = 'fileCopyError';
$$returnHashRef{errorText} = "Exit code: $hexString == $errorString";
$$returnHashRef{errorMessage}  =
"Error while trying to copy files to your local disk.\n\n" .
"The copy command was: @commandArray\n\n" .
"The exit code was: $hexString\n" .
"The code means:\n$errorString\n" .
"The error text was:\n$copyOutput\n\n" .
"Please correct this problem and try again.";
return 0;
}
elsif( ($copyStatus == 1) && ($copyOutput =~ / is not recognized as an internal /i) )
{
$$returnHashRef{error} = 'fileCopyError';
$$returnHashRef{errorText} = "The command was not found or did not operate as expected";
$$returnHashRef{errorMessage}  =
"Error while trying to copy files to your local disk.\n\n" .
"The copy command was: @commandArray\n\n" .
"The command was not found or did not operate as expected. " .
"This probably means that your Build Services and toolchain " .
"are not correctly synced to your local disk.\n\n" .
"Try running 'setupEnv --sync=force' and re-run this command.";
return 0;
}
$$returnHashRef{copied} = 1;
return 1;
}
else
{
$$returnHashRef{error} = 'fileCopyError';
$$returnHashRef{errorText} = "Unable to parse the source file string \"$sourceFileServerPath\"";
$$returnHashRef{errorMessage}  =
"Error while trying to copy files to your local disk.\n\n" .
"Unable to parse the source file string \"$sourceFileServerPath\" " .
"into path and filename elements.  Perhaps the source string " .
"does not contain a directory?  It should!";
return 0;
}
}
else
{
my $cpOptions = "";
$cpOptions .= " -f";
$cpOptions .= " -P"; # Don't follow symlinks.
$cpOptions .= " -R";
$cpOptions .= " --update"    unless $forceSync || ::isMacOSX();
$cpOptions .= " -v"; # always use '-v' so cp will produce some output for
if( ::isMacOSX() )
{
my $macOptions = $cpOptions;
$macOptions =~ s/^\s*|\s*$//g;
my @macOptionsArray = split( /\s+/, $macOptions );
if( $sourceFileServerPath =~ s@/\*$@@ )
{
my $localDestPath = $destPath;
my $preprocessSub;
if( $recursive )
{
$preprocessSub =
sub
{
my $sourceDir = ${ \$File::Find::dir };
my $relativePath = ($sourceDir =~ m@^$sourceFileServerPath/?@ && $');
$localDestPath = "$destPath/$relativePath";
if( !-d $localDestPath )
{
my @command = qw/ mkdir -p /;
push @command, '-v' if $gModuleVerbose;
push @command, $localDestPath;
my ($stat, $output) = ::shellCommand( \@command,
noDie => 1,
printCommandOutput => 0 );
if( $stat )
{
$$returnHashRef{error} = 'mkdirError';
$$returnHashRef{errorText} = "Unable to create the local file system path \"$localDestPath\"";
$$returnHashRef{errorMessage}  =
"Unable to create the local file system path \"$localDestPath\" " .
"while trying to copy files from $sourceFileServerPath " .
"to your local disk.\n  The error was: $output\n" .
"Please correct this problem and try again.";
return qw/ /;
}
}
return @_;
};
}
else
{
$preprocessSub =
sub
{
my $dir = ${ \$File::Find::dir };
return grep{ ! -d "$dir/$_" || -l "$dir/$_" } @_;
};
}
my $prevNlink = $File::Find::dont_use_nlink;
if( getFileServerName( $sourcePerforcePath, $sourceExportToken )
!~ /^(nirvana|hades)$/i )
{
$File::Find::dont_use_nlink = 1;
::logStr "dont_use_nlink = 1", $gModuleVerbose;
}
find( {
preprocess => $preprocessSub,
no_chdir => 1,
wanted => sub{
_macosxCopyFile(
@macOptionsArray,
${ \$File::Find::name },
${ \$localDestPath },
$forceSync,
$returnHashRef );
}
},
$sourceFileServerPath
);
$File: //ComputerBasedInstruments/RF/software/rfFileIO/trunk/1.0/buildToolsRedirect.pl $prevNlink;
}
else
{
if( $recursive )
{
mxDie "Internal Error: _copyFilesToLocalDisk() called with " .
"\$recursive==1, but \$sourceFileServerPath does not " .
"end in a wildcard.";
}
_macosxCopyFile( @macOptionsArray, $sourceFileServerPath, $destPath,
$forceSync, $returnHashRef );
}
}
else
{
my $copyCommand;
if( !$recursive && $sourceFileServerPath =~ m@^(.*)/\*@ )
{
my $directory = $1;
my @listing;
my @files;
::logStr "the copy is not recursive and ends in a simple wildcard", $gModuleVerbose;
if( opendir(DIRHANDLE, $directory) )
{
@listing = readdir DIRHANDLE;
closedir DIRHANDLE;
foreach my $entry ( @listing )
{
if( !_isDirectory( "$directory/$entry" ) )
{
push(@files, "\"$directory/$entry\"");
}
}
if( @files )
{
$copyCommand = " " . join(' ', @files) . " \"$destPath\"";
}
}
}
else
{
my $escapedSource = $sourceFileServerPath;
$escapedSource =~ s@[ \(\)]@\\$&@g;
$copyCommand = " $escapedSource \"$destPath\"";
::logStr "the copy is recursive or it does not end in a simple wildcard", $gModuleVerbose;
}
if( defined $copyCommand )
{
my $command = "cp $cpOptions $copyCommand";
::logStr "calling: $command", $gModuleVerbose;
my $cpOutput = `$command`;
chomp $cpOutput;
my $cpStatus = ( $? >> 8 );
if( $gModuleVerbose )
{
::logStr "cp exit code: $cpStatus", $gModuleVerbose;
::logStr "cp output:\n$cpOutput", $gModuleVerbose;
}
if( $cpStatus )
{
$$returnHashRef{error} = 'fileCopyError';
$$returnHashRef{errorText} = "The 'cp' command was not found or returned an error.";
$$returnHashRef{errorMessage}  =
"Error while trying to copy files to your local disk.\n" .
"The copy command was: $command\n" .
"The exit code was: $cpStatus\n" .
"The error text was: $cpOutput\n" .
"Please correct this problem and try again.";
return 0;
}
$$returnHashRef{copied} = 1;
return 1;
}
else
{
::logStr "nothing to copy", $gModuleVerbose;
return 0;
}
}
}
return 1;
}
sub _copyZipFilesToLocalDisk
{
my $exportPerforcePath = shift;
my $exportToken = shift;
my $exportLocalPath = shift;
my $filesToSync = shift;
my $forceSync = shift;
my $returnHashRef = shift;
my $trace = BlockTrace->new("_copyZipFilesToLocalDisk", $gModuleVerbose);
my $fileServerPath = constructFileServerPath( $exportPerforcePath,
$exportToken );
$fileServerPath =~ s@\\@/@g;
if( ! _isDirectory( $exportLocalPath ) )
{
::logStr "the destination directory ($exportLocalPath) does not " .
"exist. creating it.", $gModuleVerbose;
eval { mkpath( $exportLocalPath, $gModuleVerbose ) };
if ($@)
{
$$returnHashRef{error} = 'mkdirError';
$$returnHashRef{errorText} = "Unable to create the local file system path \"$exportLocalPath\"";
$$returnHashRef{errorMessage}  =
"Unable to create the local file system path \"$exportLocalPath\" " .
"while trying to copy files from $fileServerPath" .
"to your local disk.\n  The error was: $@\n" .
"Please correct this problem and try again.";
return 0;
}
}
my $foundMatch = 0;
$filesToSync =~ s@\.\.\.@**@;
my $zipsPath = "$fileServerPath/$kZipFilesDirectory";
if( opendir(DIR, $zipsPath) )
{
my @zips =  grep { /\.zip$/  } readdir(DIR);
closedir DIR;
my @cmd = ( 'unzip', '-a', '-o', '-d', $exportLocalPath, '-W' );
push @cmd, '-u' unless $forceSync;
foreach my $zipFile (sort @zips)
{
my $file = "$zipsPath/$zipFile";
::logStr "processing: $zipFile", $gModuleVerbose;
my @thisCommand = ( @cmd, $file, $filesToSync, );
my $unzipStatus = ::shellCommand( \@thisCommand,
noDie => 1,
printCommandOutput => 0,
escapeWildcards => 1  #  don't let the shell do
);
if( $unzipStatus == 0 )
{
$foundMatch++;
$$returnHashRef{unzippped} = 1;
}
elsif( $unzipStatus != 11 )
{
$$returnHashRef{error} = 'unzipError';
$$returnHashRef{errorText} = "Unexpected error returned from 'unzip' for $file";
$$returnHashRef{errorMessage}  =
"The unzip command returned an unexpected exit code while " .
"trying to process the exported zip file '$zipFile'.\n" .
"  exportPerforcePath : $exportPerforcePath\n" .
"  zip file           : $file\n" .
"  exit status        : $unzipStatus\n" .
"  meaning            : " . ::convertUnzipExitStatusToString($unzipStatus) . "\n" .
"  command            : @thisCommand";
return $foundMatch;
}
}
}
return $foundMatch;
}
sub _deleteFilesFromLocalDisk( $ $ $ $ $ )
{
my $sourcePerforcePath = shift;
my $deletePath = shift;
my $exportPerforcePath = shift;
my $recursive = shift;
my $returnHashRef = shift;
if( $sourcePerforcePath =~ /^$exportPerforcePath(.*)$/ )
{
$deletePath .= $1;
::logStr( "path to delete: $deletePath", $gModuleVerbose );
}
else
{
mxDie "Error: _deleteFilesFromLocalDisk() - the sourcePerforcePath and " .
"the exportPerforcePath do not match. This is probably an internal error. " .
"Please contact Systems Software.\n" .
"  sourcePerforcePath = $sourcePerforcePath\n" .
"  exportPerforcePath = $exportPerforcePath\n" .
"  deletePath = $deletePath\n";
}
my @deleteFiles;
if( !$recursive && $deletePath =~ m@^(.*)/\*@ )
{
my $directory = $1;
::logStr "the delete is not recursive and ends in a simple wildcard", $gModuleVerbose;
if( opendir(DIRHANDLE, $directory) )
{
my @listing = readdir DIRHANDLE;
closedir DIRHANDLE;
foreach my $entry ( sort @listing )
{
if( !_isDirectory( "$directory/$entry" ) )
{
push @deleteFiles, "$directory/$entry";
}
}
}
if( ! @deleteFiles )
{
::logStr "nothing to delete", $gModuleVerbose;
return;
}
}
if( ::isWindows() )
{
my @commandArray;
push @commandArray, "$ENV{nitoolchainMisc}/win32rm.exe";
if( @deleteFiles )
{
push @commandArray, @deleteFiles;
}
else
{
push @commandArray, $deletePath;
}
::logStr "calling: @commandArray", $gModuleVerbose;
my ($deleteStatus, $deleteOutput) =
::shellCommand( \@commandArray,
noDie => 1,
printCommandOutput => 0 );
chomp $deleteOutput;
$$returnHashRef{deleteOutput} = $deleteOutput;
if( ($deleteStatus == 1) && ($deleteOutput =~ / is not recognized as an internal /i) )
{
$$returnHashRef{error} = 'fileDeleteError';
$$returnHashRef{errorText} = "The command was not found or did not operate as expected";
$$returnHashRef{errorMessage}  =
"Error while trying to delete files from your local disk.\n\n" .
"The delete command was: @commandArray\n\n" .
"The command was not found or did not operate as expected. " .
"This probably means that your Build Services and toolchain " .
"are not correctly synced to your local disk.\n\n" .
"Try running 'setupEnv --sync=force' and re-run this command.";
return;
}
if( $deleteStatus )
{
$$returnHashRef{error} = 'fileDeleteError';
$$returnHashRef{errorText} = "Exit code: $deleteStatus == The delete command failed";
$$returnHashRef{errorMessage}  =
"Error while trying to delete files from your local disk.\n\n" .
"The delete command was: @commandArray\n\n" .
"The exit code was: $deleteStatus\n" .
"The output was: $deleteOutput";
return;
}
}
else
{
my $deleteFiles = '';
if( @deleteFiles )
{
foreach my $file ( @deleteFiles )
{
$deleteFiles .= "\"$file\" ";
}
}
else
{
$deleteFiles = $deletePath;
$deleteFiles =~ s@[ \(\)]@\\$&@g;
::logStr "the copy is recursive or it does not end in a simple wildcard", $gModuleVerbose;
}
my $rmCommand = "rm -f -v";
$rmCommand .= " -r" if $recursive;
$rmCommand .= " $deleteFiles";
::logStr "calling: $rmCommand", $gModuleVerbose;
my $rmOutput = `$rmCommand`;
chomp $rmOutput;
my $rmStatus = ( $? >> 8 );
$$returnHashRef{deleteOutput} = $rmOutput;
if( $gModuleVerbose )
{
::logStr "rm exit code: $rmStatus", $gModuleVerbose;
::logStr "rm output:\n$rmOutput", $gModuleVerbose;
}
if( $rmStatus )
{
$$returnHashRef{error} = 'fileDeleteError';
$$returnHashRef{errorText} = "The 'rm' command was not found or returned an error.";
$$returnHashRef{errorMessage}  =
"Error while trying to delete files from your local disk.\n" .
"The delete command was: $rmCommand\n" .
"The exit code was: $rmStatus\n" .
"The error text was: $rmOutput\n" .
"Please correct this problem and try again.";
return;
}
}
}
sub _macosxCopyFile( \@ $ $ $ $ )
{
my $cpOptionsArrayRef = shift;
my $source = shift;
my $destination = shift;
my $forceSync = shift;
my $returnHashRef = shift;
my $fileName = ($source =~ m@[^/]+$@ && $&);
my $sourceInfo      = _fileInfo($source);
my $destinationInfo = _fileInfo("$destination/$fileName");
return if( -d $source && ! -l $source );
if( $destinationInfo->{exists} &&
$destinationInfo->{modtime} >= $sourceInfo->{modtime} &&
$destinationInfo->{size} == $sourceInfo->{size} &&
!$forceSync )
{
return;
}
if( $destinationInfo->{exists} && $destinationInfo->{link} )
{
my $stat = unlink "$destination/$fileName";
if( $stat != 1 )
{
::logStr "  unlink returned '$stat' for '$destination/$fileName'", $gModuleVerbose;
}
}
my $commandArrayRef = [ 'cp', @$cpOptionsArrayRef, $source, $destination ];
my ($copyStatus, $copyOutput) =
::shellCommand( $commandArrayRef,
noDie => 1,
printCommandOutput => 0 );
if( $copyStatus )
{
$$returnHashRef{error} = 'fileCopyError';
$$returnHashRef{errorText} = "The 'cp' command was not found or returned an error.";
$$returnHashRef{errorMessage}  =
"Error while trying to copy files to your local disk.\n" .
"The copy command was: @$commandArrayRef\n" .
"The exit code was: $copyStatus\n" .
"The error text was: $copyOutput\n" .
"Please correct this problem and try again.";
}
else
{
$$returnHashRef{copied} = 1;
}
}
sub _fileInfo( $ )
{
my $item = shift;
my @stat    = stat $item;
my $ino     = $stat[1];
my @lstat   = lstat $item;
my $lino    = $lstat[1];
my $size    = $lstat[7];
my $lmtime  = $lstat[9];
return { 'exists'  => defined($ino),
'link'    => defined($ino) && ($lino != $ino),
'size'    => defined($ino) ? $size : 0,
'modtime' => defined($ino) ? $lmtime : 0
};
}
}
{ ###@@ Marker for Build Services - setupToolchainHelper.pm @@
sub checkAndSync($$@);
sub checkIfFilesExist(@);
sub syncThisExport( $ ; $ );
sub checkAndSync($$@)
{
my $pathHashRef = shift;
my $description = shift;
my @files = @_;
my $perforcePath = $$pathHashRef{perforcePath};
my $trace = BlockTrace->new( "checkAndSync( $perforcePath, $description )" );
my $allExist = checkIfFilesExist(@files);
logStr "All files are not present.  Must sync." if ($allExist == 0);
if( $gSyncMode eq 'force' )
{
logStr "sync option is 'force'.  Must sync.";
$allExist = 0;
}
if( $allExist == 0 )
{
my $doSync = 1;
if( $gSyncMode eq 'ask' )
{
printStr "It appears that you do not have the $description export";
printStr "sync'ed to your machine.  Do you want to sync";
printStrNoNewline "$perforcePath now?  [yes|no] ";
$| = 1;
print "";
$| = 0;
my $input = <STDIN>;
print "\n";
if($input !~ /^\s*(y|yes)\s*$/i)
{
$doSync = 0;
}
}
elsif( $gSyncMode eq 'no' )
{
logStr "sync option is 'no'.";
$doSync = 0;
}
elsif( $gSyncMode eq 'yes' )
{
logStr "sync option is 'yes'.";
$doSync = 1;
}
if( $doSync == 1 )
{
my $forceSync = ($gSyncMode eq 'force');
syncThisExport($pathHashRef, $forceSync);
logStr "sync was successful";
if( checkIfFilesExist(@files) == 0 )
{
if( $gSyncMode eq 'force' )
{
mxWarn "WARNING: The \"forced\" sync operation of $perforcePath ($description) " .
"succeeded but some of the expected files are not on your local disk. " .
"You should use your Perforce client (p4 or p4win) to check " .
"this path and see why it is not really sync'ed to your disk. " .
"You may not be able use the Build Services until this export is sync'ed.";
}
else
{
mxWarn "WARNING: The Perforce sync operation of $perforcePath ($description) " .
"succeeded but some of the expected files are not on your local disk. " .
"The sync will now be repeated with the \"force\" option set " .
"to ensure that the files are actually sync'ed from Perforce.";
my $oldSyncMode = $gSyncMode;
$gSyncMode = 'force';
checkAndSync($pathHashRef, $description, @files);
$gSyncMode = $oldSyncMode;
}
}
}
else
{
logStr "A Perforce sync of $perforcePath was required but was not performed.";
mxWarn "WARNING: You have chosen not to sync the $description export. " .
"You may not be able use the Build Services until this export is sync'ed.";
}
}
}
sub checkIfFilesExist(@)
{
my @files = @_;
my $allExist = 1;
foreach my $file (@files)
{
if( -f $file )
{
logStr "$file does exist";
}
else
{
logStr "$file does NOT exist";
$allExist = 0;
}
}
return $allExist;
}
}
{
$Getopt::Long::ignorecase = 0;
&GetOptions( \%gOptions,
"help|h|?",
"verbose|v:1",
"version",
"setupEnvVersion:i",
"ignoreCache!",
"cacheDir=s",
"scriptType=s",
"sync=s"
) or mxDie "Error parsing command-line options: $!\n" .
"Try `$gScriptName --help` for more information.";
if( $gOptions{help} || @ARGV > 1 )
{
print $gHelpStr;
exit;
}
elsif( $gOptions{version} )
{
print <<EOT
$0 : Build Services Support Tool
 ($gScriptPerforceId)
 ($kBuildServicesTrunkLastChange)
EOT
;
exit;
}
setVerboseOutput( $gOptions{verbose} );
my $trace = BlockTrace->new("---- $0 ----");
logStr "($gScriptPerforceId)";
if( $gOptions{"verbose"} )
{
logStr "command-line options:";
foreach my $option( sort (keys %gOptions) )
{
logStr "  $option ==> $gOptions{$option}";
}
}
if( !defined $gOptions{'setupEnvVersion'} )
{
mxDie "Command-line usage error. Make sure your copy of setupEnv is " .
"up to date.";
}
logStr "setupEnvVersion = $gOptions{'setupEnvVersion'}";
my $scriptType;
if (defined($gOptions{'scriptType'}))
{
$scriptType = "--scriptType=$gOptions{'scriptType'}";
}
$gSyncMode = 'yes';
if ( defined($gOptions{'sync'}) )
{
if( $gOptions{'sync'} eq 'yes' )
{
$gSyncMode = 'yes';
}
elsif( $gOptions{'sync'} eq 'no' )
{
$gSyncMode = 'no';      # If a sync is needed, don't do it (no prompting).
}
elsif( $gOptions{'sync'} eq 'force' )
{
$gSyncMode = 'force';
}
elsif( $gOptions{'sync'} eq 'ask' )
{
$gSyncMode = 'ask';
}
else {
mxDie "ERROR: The option --sync was not speficied correctly. You entered " .
"\"$gOptions{'sync'}\" instead of yes, no, force, or ask.";
}
}
logStr "sync = $gSyncMode";
$gIgnoreCache = 0;
$gIgnoreCache = $gOptions{'ignoreCache'} if defined($gOptions{'ignoreCache'});
logStr "ignoreCache = $gIgnoreCache";
$gCacheDir = './objects/_dependencies/build';
$gCacheDir = $gOptions{'cacheDir'} if defined($gOptions{'cacheDir'});
logStr "cacheDir = $gCacheDir";
if( !(-f 'package') )
{
mxDie "ERROR: This script must be run from the component's " .
"root directory, which must have a package file.";
}
my $redirectCacheFile = "$gCacheDir/.redirect";
my $cacheSourceFile   = 'package';
my $useCache = 0;
if( $gIgnoreCache == 1 )
{
logStr "Removing $redirectCacheFile (ignoreCache)";
unlink $redirectCacheFile;
}
my $batchFile = "$gCacheDir/fixupPath.bat";
if( -f $batchFile )
{
logStr "Removing $batchFile";
unlink $batchFile;
}
$batchFile = "$gCacheDir/fixupPath.sh";
if( -f $batchFile )
{
logStr "Removing $batchFile";
unlink $batchFile;
}
if( $gSyncMode eq 'force' )
{
$useCache = 0;
logStr "Sync mode is set to 'force'. Ignoring the cache.";
}
else
{
logStr "Checking for $redirectCacheFile";
if( -f $redirectCacheFile )
{
logStr "Cache file exists, reading timestamps";
my $cacheFileStat = stat($redirectCacheFile);
logStr "  $redirectCacheFile: " . localtime($cacheFileStat->mtime);
my $sourceFileStat = stat($cacheSourceFile);
logStr "  $cacheSourceFile: " . localtime($sourceFileStat->mtime);
if (defined($cacheFileStat) && defined($sourceFileStat) &&
($cacheFileStat->mtime > $sourceFileStat->mtime)) {
logStr "Cache file is current, reading it";
open TEXTFILE, "<$redirectCacheFile"
or mxDie "ERROR: Can't open $redirectCacheFile for reading : $!";
my $cacheVersion = <TEXTFILE>;
chomp($cacheVersion);
if($cacheVersion eq $kCacheFileVersionNumber)
{
$gBuildServicesPerforcePath = <TEXTFILE>;
$gBuildServicesLocalPath = <TEXTFILE>;
chomp ($gBuildServicesPerforcePath);
chomp ($gBuildServicesLocalPath);
if( ($gBuildServicesPerforcePath ne "") && ($gBuildServicesLocalPath ne "") )
{
logStr "Cached data:";
logStr "  Build Services Perforce path: $gBuildServicesPerforcePath";
logStr "  Build Services local path: $gBuildServicesLocalPath";
logStr "Checking for some expected files";
my $filesExist = checkIfFilesExist("$gBuildServicesLocalPath/package",
"$gBuildServicesLocalPath/includes/begin.mak",
"$gBuildServicesLocalPath/tools/allos/allproc/_setupToolchain.pl",
"$gBuildServicesLocalPath/tools/win32/i386/_setupToolchain.exe");
if($filesExist == 1)
{
$useCache = 1;
logStr "All expected files found. Using cached data.";
}
else
{
logStr "Could not locate all the expected files. Ignoring cached data.";
}
}
else
{
logStr "Problem reading the contents of the cache file. Ignoring the cache.";
}
}
else
{
logStr "Cache file version number ($cacheVersion) is not " .
"\"$kCacheFileVersionNumber\". Ignoring the cache.";
}
close TEXTFILE;
}
else {
logStr "Cache file is out of date";
}
}
else
{
logStr "Cache file does NOT exists";
}
}
if( $useCache == 0 )
{
locateAndSyncBuildServices();
}
my @setupToolchain;
if( isWindows() )
{
@setupToolchain = ("$gBuildServicesLocalPath/tools/win32/i386/_setupToolchain.exe");
}
else
{
@setupToolchain = ("perl",
"$gBuildServicesLocalPath/tools/allos/allproc/_setupToolchain.pl");
}
my @commandLine = ( @setupToolchain,
"--setupEnvVersion=$gOptions{'setupEnvVersion'}",
"--buildToolsRedirectVersion=$gBuildToolsRedirectVersion",
"--batchDir=$gCacheDir",
"--sync=$gSyncMode",
"--buildServicesPerforcePath=$gBuildServicesPerforcePath",
"--buildServicesLocalPath=$gBuildServicesLocalPath",
"--useCache=$useCache"
);
push @commandLine, $scriptType if defined $scriptType;
push @commandLine, "--verbose=$gOptions{'verbose'}" if $gOptions{"verbose"};
logStr "Calling @commandLine";
my $exitStatus = makeSystemCall(@commandLine);
mxDie "Error calling _setupToolchain" unless( $exitStatus == 0 );
&$_() foreach @gENDs;
exit 0;
}
sub locateAndSyncBuildServices()
{
my $localPath = cleanUpPath( '.', 1 );
printStr "Using Perforce to lookup the Build Services export";
logStr "localPath = $localPath";
my $packageFile = "$localPath/package";
logStr "Reading package file: $packageFile";
if( -f $packageFile )
{
my $foundComponent = 0;
my $componentAlias;
my $foundDependency = 0;
my $dependencyPerforcePath;
open TEXTFILE, "<$packageFile"
or mxDie "Can't open $packageFile for reading: $!";
while( <TEXTFILE> )
{
if( !$foundComponent && !$foundDependency && /^\s*component\s+(\S+)\s*$/ )
{
$foundComponent = 1;
$componentAlias = $1;
}
elsif( $foundComponent && !$foundDependency && /^\s*dependency\s+nibuild\s*$/ )
{
$foundDependency = 1;
}
elsif( $foundComponent && $foundDependency && /^\s*perforcePath\s*=\s*([^; ]+)\s*;\s*$/ )
{
$dependencyPerforcePath = $1;
last;
}
}
close TEXTFILE or mxDie "Can't close $packageFile: $!";
if(!defined($componentAlias))
{
mxDie( "ERROR: This package file ($packageFile) does not contain " .
"a 'component' section to describe this component. " .
"Please contact the Systems Software group or view the web pages " .
"at <http://ss.ni.com/build/> if you need help setting up and " .
"using the Build Services." );
}
logStr "This component is $componentAlias";
if($componentAlias eq "nibuild")
{
logStr "We must be running in a build services export directory.";
logStr "Using this directory as the build services path.";
($gBuildServicesPerforcePath) = resolvePath('.');
}
else
{
if(!defined($dependencyPerforcePath))
{
mxDie( "ERROR: This package file ($packageFile) does not contain " .
"a dependency on nibuild.  You component's package file must " .
"contain a dependency called 'nibuild' and point to an export " .
"in the //sa/ss/build/export hierarchy. " .
"Please contact the Systems Software group or view the web pages " .
"at <http://ss.ni.com/build/> if you need help setting up and " .
"using the Build Services." );
}
$gBuildServicesPerforcePath = $dependencyPerforcePath;
}
($gBuildServicesPerforcePath, $gBuildServicesLocalPath) =
resolvePath($gBuildServicesPerforcePath);
logStr "Dependency nibuild:";
logStr "  Perforce path is $gBuildServicesPerforcePath";
logStr "  Local path is $gBuildServicesLocalPath";
my %syncPathHash;
$syncPathHash{perforcePath} = $gBuildServicesPerforcePath;
$syncPathHash{localPath} = $gBuildServicesLocalPath;
checkAndSync( \%syncPathHash, "Build Services",
"$gBuildServicesLocalPath/package",
"$gBuildServicesLocalPath/includes/begin.mak",
"$gBuildServicesLocalPath/tools/allos/allproc/_setupToolchain.pl",
"$gBuildServicesLocalPath/tools/win32/i386/_setupToolchain.exe" );
}
else
{
mxDie( "ERROR: This component trunk directory ($localPath) " .
"does not contain a package file.  The Build Services cannot be " .
"setup unless your component contains a package file with a" .
"dependency on 'nibuild'. " .
"Please contact the Driver Services group or view the web pages " .
"at <http://ss.ni.com/build/> if you need " .
"help setting up and using the Build Services." );
}
}
sub syncThisExport( $ ; $ )
{
my $exportPathHashRef = shift;
my $forceSync = shift || 0;
my $perforcePath = $$exportPathHashRef{perforcePath};
printStr "Syncing $perforcePath/...";
my @commandArray = qw/sync/;
push @commandArray, '-f' if $forceSync;
push @commandArray, "$perforcePath/...";
my $serverName;
($perforcePath, $serverName) = p4PathCheck( $perforcePath );
p4Cmd( $serverName, \@commandArray );
if ( defined($::gP4Err) && ($::gP4Err !~ /file\(s\) up-to-date/) )
{
mxDie "Perforce error: $::gP4Err";
}
}
